@doc raw"""
    SvärdKalischEquations1D(gravity, eta0 = 0.0, alpha = 0.0, beta = 0.2308939393939394, gamma = 0.04034343434343434)

Dispersive system by Svärd and Kalisch in one spatial dimension with spatially varying bathymetry. The equations are given in conservative variables are given by
```math
\begin{aligned}
  h_t + (hv)_x &= (\hat\alpha(\hat\alpha(h + b)_x)_x)_x,\\
  (hv)_t + (hv^2)_x + gh(h + b)_x &= (\hat\alpha v(\hat\alpha(h + b)_x)_x)_x + (\hat\beta v_x)_{xt} + \frac{1]{2}(\hat\gamma v_x)_{xx} + \frac{1}{2}(\hat\gamma v_{xx})_x
\end{aligned},
``
where ``\hat\alpha^2 = \alpha\sqrt(gh)h^2``, ``\hat\beta = \beta h^3``, ``\hat\gamma = \gamma\sqrt(gh)h^3``. The coefficients ``\alpha``, ``\beta`` and ``\gamma`` are provided in dimensionless form.
The equations can be rewritten in primitive variables as
```math
\begin{aligned}
  \eta_t + ((\eta + D)v)_x = (\hat\alpha(\hat\alpha\eta_x)_x)_x,\\
  v_t(\eta + D) - v((\eta + D)v)_x + ((\eta + D)v^2)_x + g(\eta + D)\eta_x &= (\hat\alpha v(\hat\alpha\eta_x)_x)_x - v(\hat\alpha(\hat\alpha\eta_x)_x)_x + (\hat\beta v_x)_{xt} + \frac{1]{2}(\hat\gamma v_x)_{xx} + \frac{1}{2}(\hat\gamma v_{xx})_x
\end{aligned}.
```
The unknown quantities of the Svärd equations are the total water height ``\eta`` and the velocity ``v``.
The gravitational constant is denoted by `g` and the bottom topography (bathymetry) ``b = -D > 0``. The water height above the bathymetry is therefore given by
``h = \eta + D``.

The equations by Svärd and Kalisch are presented and analyzed in
- Magnus Svärd, Henrik Kalisch (2023)
  A novel energy-bounded Boussinesq model and a well-balanced and stable numerical discretization
  [arXiv: 2302.09924](https://arxiv.org/abs/2302.09924)

"""
struct SvaerdKalischEquations1D{RealT <: Real} <: AbstractSvaerdKalischEquations{1, 3}
    gravity::RealT # gravitational constant
    eta0::RealT    # constant "lake-at-rest" total water height
    alpha::RealT   # coefficient
    beta::RealT    # coefficient
    gamma::RealT   # coefficient
end

const SvärdKalischEquations1D = SvaerdKalischEquations1D

function SvaerdKalischEquations1D(; gravity_constant, eta0 = 0.0, alpha = 0.0,
                                  beta = 0.2308939393939394, gamma = 0.04034343434343434)
    SvaerdKalischEquations1D(gravity_constant, eta0, alpha, beta, gamma)
end

varnames(::SvaerdKalischEquations1D) = ("eta", "v", "D")

# TODO: Initial condition should not get a `mesh`
"""
    initial_condition_sin_bathymetry(x, t, equations::SvaerdKalischEquations1D, mesh)

An initial condition with a Gaussian bump as initial water height with still water and
a sine-shaped bathymetry.
"""
function initial_condition_sin_bathymetry(x, t, equations::SvaerdKalischEquations1D, mesh)
    eta = 2.0 + 2.0 * exp(-12.0 * x^2)
    v = 0.0
    D = -1.0 + 0.1 * sinpi(2.0 * x)
    return SVector(eta, v, D)
end

# TODO: Initial condition should not get a `mesh`
"""
    initial_condition_dingemans(x, t, equations::SvaerdKalischEquations1D, mesh)

The initial condition that uses the dispersion relation of the Euler equations
to approximate waves generated by a wave maker as it is done by experiments of
Dingemans. The topography is a trapesoidal.

References:
- Magnus Svärd, Henrik Kalisch (2023)
  A novel energy-bounded Boussinesq model and a well-balanced and stable numerical discretization
  [arXiv: 2302.09924](https://arxiv.org/abs/2302.09924)
- Maarten W. Dingemans (1994)
  Comparison of computations with Boussinesq-like models and laboratory measurements
  [link](https://repository.tudelft.nl/islandora/object/uuid:c2091d53-f455-48af-a84b-ac86680455e9/datastream/OBJ/download)
"""
function initial_condition_dingemans(x, t, equations::SvaerdKalischEquations1D, mesh)
    h0 = 0.8
    A = 0.02
    #     omega = 2*pi/(2.02*sqrt(2))
    K = 0.8406220896381442 # precomputed result of find_zero(K -> omega^2 - equations.gravity * K * tanh(K * h0), 1.0) using Roots.jl
    if x < -30.5 * pi / K || x > -8.5 * pi / K
        h = 0.0
    else
        h = A * cos(K * x)
    end
    v = sqrt(equations.gravity / K * tanh(K) * h0) * h / h0
    if x < 11.01 || x >= 33.07
        b = 0.0
    elseif 11.01 <= x && x < 23.04
        b = 0.6 * (x - 11.01) / (23.04 - 11.01)
    elseif 23.04 <= x && x < 27.04
        b = 0.6
    elseif 27.04 <= x && x < 33.07
        b = 0.6 * (33.07 - x) / (33.07 - 27.04)
    else
        error("should not happen")
    end
    eta = h + h0
    D = -b
    return SVector(eta, v, D)
end

function create_cache(mesh,
                      equations::SvaerdKalischEquations1D,
                      solver::Solver,
                      initial_condition,
                      RealT,
                      uEltype)
    hmD1betaD1 = Array{RealT}(undef, nnodes(mesh), nnodes(mesh))
    alpha_hat = Array{RealT}(undef, nnodes(mesh))
    beta_hat = similar(alpha_hat)
    gamma_hat = similar(alpha_hat)
    tmp1 = similar(alpha_hat)
    tmp2 = similar(alpha_hat)
    dbeta_hat = similar(alpha_hat)
    return (hmD1betaD1 = hmD1betaD1, alpha_hat = alpha_hat, beta_hat = beta_hat,
            gamma_hat = gamma_hat, tmp1 = tmp1, tmp2 = tmp2, dbeta_hat = dbeta_hat)
end

# Discretization that conserves the mass (for eta and v) and is energy-bounded for periodic boundary conditions
function rhs!(du_ode, u_ode, t, mesh, equations::SvaerdKalischEquations1D,
              initial_condition,
              ::BoundaryConditionPeriodic, solver, cache)
    @unpack hmD1betaD1, alpha_hat, beta_hat, gamma_hat, tmp1, tmp2, dbeta_hat = cache

    u = wrap_array(u_ode, mesh, equations, solver)
    du = wrap_array(du_ode, mesh, equations, solver)

    eta = view(u, 1, :)
    v = view(u, 2, :)
    D = view(u, 3, :)
    deta = view(du, 1, :)
    dv = view(du, 2, :)
    dD = view(du, 3, :)
    fill!(dD, zero(eltype(dD)))

    #     @show t
    @. alpha_hat = sqrt(equations.alpha * sqrt(equations.gravity * (eta + D)) *
                        ((eta + D)^2))
    @. beta_hat = equations.beta * (eta + D)^3
    @. gamma_hat = equations.gamma * sqrt(equations.gravity * (eta + D)) * ((eta + D)^3)

    tmp1 = alpha_hat .* (solver.D1 * (alpha_hat .* (solver.D1 * eta)))
    @. tmp2 = tmp1 - (D * v + eta * v)
    mul!(deta, solver.D1, tmp2)

    hmD1betaD1 = Diagonal(eta .+ D) -
                 Matrix(solver.D1) * Diagonal(beta_hat) * Matrix(solver.D1)
    @. dbeta_hat = 3 * equations.beta * (eta + D)^2 * deta
    # split form
    tmp2 = -(0.5 *
             (solver.D1 * ((eta .+ D) .* v .^ 2) + ((eta .+ D) .* v) .* (solver.D1 * v) -
              v .* (solver.D1 * ((eta .+ D) .* v))) +
             equations.gravity * (eta .+ D) .* (solver.D1 * eta) +
             0.5 *
             (v .* (solver.D1 * tmp1) - solver.D1 * (v .* tmp1) - tmp1 .* (solver.D1 * v)) -
             solver.D1 * (dbeta_hat .* (solver.D1 * v)) -
             0.5 * solver.D1 * (gamma_hat .* (solver.D2 * v)) -
             0.5 * solver.D2 * (gamma_hat .* (solver.D1 * v)))
    #     ldiv!(dv, hmD1betaD1, tmp2)
    dv[:] = hmD1betaD1 \ tmp2
    @show t, maximum(abs.((solver.D1 * eta))), maximum(abs.(solver.D2 * v)),
          maximum(abs.(dv)), maximum(abs.(tmp2))
    @show maximum(abs.(0.5 * solver.D1 * (gamma_hat .* (solver.D2 * v)) -
                       0.5 * solver.D2 * (gamma_hat .* (solver.D1 * v))))

    return nothing
end

@inline function waterheight_total(u, equations::SvaerdKalischEquations1D)
    return u[1]
end

@inline function velocity(u, equations::SvaerdKalischEquations1D)
    return u[2]
end

@inline function bathymetry(u, equations::SvaerdKalischEquations1D)
    return -u[3]
end

@inline function waterheight(u, equations::SvaerdKalischEquations1D)
    return waterheight_total(u, equations) - bathymetry(u, equations)
end

@inline function energy_total(u, equations::SvaerdKalischEquations1D)
    eta, v, D = u
    e = equations.gravity * eta^2 + (D + eta) * v^2
    return e
end

@inline entropy(u, equations::SvaerdKalischEquations1D) = energy_total(u, equations)

# Calculate the error for the "lake-at-rest" test case where eta should
# be a constant value over time
@inline function lake_at_rest_error(u, equations::SvaerdKalischEquations1D)
    eta, _, _ = u
    return abs(equations.eta0 - eta)
end
