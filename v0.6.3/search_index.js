var documenterSearchIndex = {"docs":
[{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"DispersiveShallowWater.jl is an open-source project and we are very happy to accept contributions from the community. Please feel free to open issues or submit patches (preferably as pull requests) any time.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"DispersiveShallowWater.jl and its contributions are licensed under the MIT license (see License). As a contributor, you certify that all your contributions are in conformance with the Developer Certificate of Origin (Version 1.1), which is reproduced below.","category":"page"},{"location":"contributing/#Developer-Certificate-of-Origin-(Version-1.1)","page":"Contributing","title":"Developer Certificate of Origin (Version 1.1)","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The following text was taken from https://developercertificate.org:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Developer Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n1 Letterman Drive\nSuite D4700\nSan Francisco, CA, 94129\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.","category":"page"},{"location":"development/#Development","page":"Development","title":"Development","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"If you have any suggestions or ideas for improvements or new features, we are pleased to accept and discuss issues or if you are willing to contribute, feel free to open a pull request, even if it is only fixing a typo or improving the docs.","category":"page"},{"location":"development/#Changing-DispersiveShallowWater.jl-and-running-it-locally","page":"Development","title":"Changing DispersiveShallowWater.jl and running it locally","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"If you plan to edit DispersiveShallowWater.jl, you first need to clone a local copy of the repository, which can be done by using git. It is recommended that you create a project, e.g. call it run, inside the repository, where you can add packages that you use during executing and testing DispersiveShallowWater.jl, but are not needed by DispersiveShallowWater.jl. This way you can keep the Project.toml of the main repository clean. To do so, you can execute the following lines in a terminal:","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"git clone https://github.com/NumericalMathematics/DispersiveShallowWater.jl.git\ncd DispersiveShallowWater\nmkdir run\ncd run\njulia --project=. -e 'using Pkg; Pkg.develop(PackageSpec(path=\"..\"))' # Install local DispersiveShallowWater.jl clone\njulia --project=. -e 'using Pkg; Pkg.add([\"OrdinaryDiffEqTsit5\", \"Plots\", \"SummationByPartsOperators\"])' # Install additional packages","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"If you use other packages for executing DispersiveShallowWater.jl, you can add them to the project in the run directory in an analogous way as above. To use the Julia project within run, be sure to start the Julia REPL by","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"julia --project=.","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"if already inside the the run directory or julia --project=run if in the main directory of the repo.","category":"page"},{"location":"development/#Preview-of-the-documentation","page":"Development","title":"Preview of the documentation","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"If you want to build the documentation locally, you can run","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"julia --project=docs -e 'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()'","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"once from the DispersiveShallowWater.jl main directory to tell Documenter.jl to build the documentation of your local clone. To build the documentation, run","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"julia --project=docs --color=yes docs/make.jl","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"The resulting .html files can then be found in docs/build/ and you can look at them by opening them in a browser. For pull requests from the main repository (i.e. not from a fork), the documentation is automatically built and can be previewed under https://NumericalMathematics.github.io/DispersiveShallowWater.jl/previews/PRXXX/ where XXX is the number of the pull request.","category":"page"},{"location":"dispersion/#Dispersive-properties-of-the-equations","page":"Dispersion","title":"Dispersive properties of the equations","text":"","category":"section"},{"location":"dispersion/","page":"Dispersion","title":"Dispersion","text":"The equations implemented in DispersiveShallowWater.jl describe the propagation of waves in a shallow water system. The equations are dispersive, meaning that the phase speed of the waves depends on their wavelength. This is in contrast to non-dispersive waves, where all waves travel at the same speed, such as the solution to the shallow water equations linearized around a state with vanishing velocity and constant water height h_0. In this case the phase speed is constantly given by c_0 = sqrtg h_0, where g is the acceleration due to gravity and h_0 is a reference water height.","category":"page"},{"location":"dispersion/","page":"Dispersion","title":"Dispersion","text":"The linear dispersion relation of a wave equation describes the relationship between the angular frequency omega and the wavenumber k of a wave. The angular frequency is related to the period T of the wave by omega = 2pi  T and the wavenumber is related to the wavelength lambda by k = 2pi  lambda. The simple case of just one wave traveling with speed c is a harmonic (or plane wave) solution of the form eta(t x) = mathrme^mathrmi(k x - omega t) with c = omega  k. The linear dispersion relation of a wave equation is then derived by substituting this solution into a linearized version of the equation and solving for omega in terms of k.","category":"page"},{"location":"dispersion/","page":"Dispersion","title":"Dispersion","text":"Since all the equations implemented in DispersiveShallowWater.jl are approximations to the full wave equations given by the Euler equations, their dispersion relations do not describe the exact speed of waves, but only an approximation to it, where the approximation usually becomes better for longer wavelengths. The dispersion relation of the full wave system is given by","category":"page"},{"location":"dispersion/","page":"Dispersion","title":"Dispersion","text":"omega(k) = pm sqrtg k tanh(h_0 k)","category":"page"},{"location":"dispersion/","page":"Dispersion","title":"Dispersion","text":"In DispersiveShallowWater.jl, we can investigate the dispersion relations of the different equations. Let us plot the wave speeds of the different equations normalized by the shallow water wave speed c_0 as a function of the wave number. We pick a reference water height of h_0 = 08 and gravitational acceleration of g = 981.","category":"page"},{"location":"dispersion/","page":"Dispersion","title":"Dispersion","text":"using DispersiveShallowWater\nusing Plots\n\neta0 = 0.0\nreference_height() = 0.8\nh0 = reference_height()\ng = 9.81\ndisp_rel = LinearDispersionRelation(h0)\nk = 0.01:0.01:5.0\n\neuler = EulerEquations1D(; gravity = g, eta0 = eta0)\nc_euler = wave_speed.(disp_rel, euler, k; normalize = true)\nplot(k, c_euler, label = \"Euler\", xlabel = \"k\", ylabel = \"c / c_0\", legend = :topright)\n\nbbm = BBMEquation1D(; gravity = g, eta0 = eta0, D = h0)\nc_bbm = wave_speed.(disp_rel, bbm, k; normalize = true)\nplot!(k, c_bbm, label = \"BBM\")\n\nsk = SvaerdKalischEquations1D(; gravity = g, eta0 = eta0)\nc_sk = wave_speed.(disp_rel, sk, k; normalize = true)\nplot!(k, c_sk, label = \"Svärd-Kalisch\")\n\nsgn = SerreGreenNaghdiEquations1D(; gravity = g, eta0 = eta0)\nc_sgn = wave_speed.(disp_rel, sgn, k; normalize = true)\nplot!(k, c_sgn, label = \"Serre-Green-Naghdi\")\n\nsavefig(\"dispersion_relations.png\") # hide\nnothing # hide","category":"page"},{"location":"dispersion/","page":"Dispersion","title":"Dispersion","text":"(Image: dispersion relations)","category":"page"},{"location":"dispersion/","page":"Dispersion","title":"Dispersion","text":"To verify that the wave speed predicted by the dispersion relation is indeed the observed one, let us simulate a simple wave traveling in a domain with periodic boundary conditions. We initialize the wave as a traveling wave for the Euler equations by using the dispersion relation. As an example we solve the problem with the Svärd-Kalisch equations.","category":"page"},{"location":"dispersion/","page":"Dispersion","title":"Dispersion","text":"using OrdinaryDiffEqTsit5\nusing Printf\n\nequations = sk\nwave_number() = 3.0\nfrequency(k) = disp_rel(euler, k)\n\nfunction initial_condition_traveling_wave(x, t, equations, mesh)\n    k = wave_number()\n    omega = frequency(k)\n    h0 = reference_height()\n    A = 0.02\n    h = A * cos(k * x - omega * t)\n    v = sqrt(equations.gravity / k * tanh(k * h0)) * h / h0\n    eta = h + equations.eta0\n    D = h0\n    return SVector(eta, v, D)\nend\n\nk = wave_number()\ncoordinates_min = 0\ncoordinates_max = 10 * pi / k # five waves (wave length = 2pi/k)\nN = 512\nmesh = Mesh1D(coordinates_min, coordinates_max, N)\n\n# create solver with periodic SBP operators of accuracy order 4\naccuracy_order = 4\nsolver = Solver(mesh, accuracy_order)\n\n# semidiscretization holds all the necessary data structures for the spatial discretization\nsemi = Semidiscretization(mesh, equations, initial_condition_traveling_wave, solver,\n                          boundary_conditions = boundary_condition_periodic)\n\ntspan = (0.0, 3.0)\node = semidiscretize(semi, tspan)\n\nsaveat = range(tspan..., length = 201)\nsol = solve(ode, Tsit5(), abstol = 1e-7, reltol = 1e-7,\n            save_everystep = false, saveat = saveat, tstops = saveat)\n\nx = 0.2 * (coordinates_max - coordinates_min)\nc_euler = wave_speed(disp_rel, euler, k)\nc = wave_speed(disp_rel, equations, k)\nanim = @animate for step in eachindex(sol.u)\n    t = sol.t[step]\n    x_t_euler = x + c_euler * t\n    x_t = x + c * t\n    index = argmin(abs.(DispersiveShallowWater.grid(semi) .- x_t))\n    scatter([x_t_euler], [initial_condition_traveling_wave(x_t_euler, t, euler, mesh)],\n            color = :blue, label = nothing)\n    eta, = sol.u[step].x\n    scatter!([x_t], [eta[index]],\n             color = :green, label = nothing)\n    plot!(semi => sol, plot_initial = true, plot_bathymetry = false,\n          conversion = waterheight_total, step = step, legend = :topleft, linewidth = 2,\n          plot_title = @sprintf(\"t = %.3f\", t), yrange = (eta0 - 0.03, eta0 + 0.03),\n          linestyles = [:solid :dot], labels = [\"Euler\" \"Svärd-Kälisch\"],\n          color = [:blue :green])\nend\ngif(anim, \"traveling_waves.gif\", fps = 25)\n\nnothing # hide","category":"page"},{"location":"dispersion/","page":"Dispersion","title":"Dispersion","text":"(Image: traveling waves)","category":"page"},{"location":"dispersion/","page":"Dispersion","title":"Dispersion","text":"The dots in the movie show that the wave speed predicted by the dispersion relation is indeed the same as the one obtained by numerically solving the equations. As expected from the plot above the wave speed of the Svärd-Kalisch equations is a bit faster than the correct one, which is due to the approximation made in the equations.","category":"page"},{"location":"changelog_tmp/#Changelog","page":"Changelog","title":"Changelog","text":"","category":"section"},{"location":"changelog_tmp/","page":"Changelog","title":"Changelog","text":"DispersiveShallowWater.jl follows the interpretation of semantic versioning (semver) used in the Julia ecosystem. Notable changes will be documented in this file for human readability.","category":"page"},{"location":"changelog_tmp/#Changes-in-the-v0.6-lifecycle","page":"Changelog","title":"Changes in the v0.6 lifecycle","text":"","category":"section"},{"location":"changelog_tmp/#Added","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog_tmp/","page":"Changelog","title":"Changelog","text":"Add initial support for ForwardDiff.jl for HyperbolicSerreGreenNaghdiEquations1D and DispersiveShallowWater.jacobian (#185).","category":"page"},{"location":"changelog_tmp/#Changes-when-updating-to-v0.6-from-v0.5.x","page":"Changelog","title":"Changes when updating to v0.6 from v0.5.x","text":"","category":"section"},{"location":"changelog_tmp/#Changed","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog_tmp/","page":"Changelog","title":"Changelog","text":"The keyword argument and function gravity_constant have been changed to gravity (#174).","category":"page"},{"location":"changelog_tmp/#Changes-in-the-v0.5-lifecycle","page":"Changelog","title":"Changes in the v0.5 lifecycle","text":"","category":"section"},{"location":"changelog_tmp/#Added-2","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog_tmp/","page":"Changelog","title":"Changelog","text":"Add LinearDispersionRelation and documentation about dispersion (#168).\nReflecting boundary conditions are added for the Svärd-Kalisch equations with alpha = gamma = 0 (#166).\nFix a bug in the upwind discretization of the SvärdKalischEquations1D.\nUse OrdinaryDiffEqTsit5.jl and OrdinaryDiffEqLowStorageRK.jl instead of OrdinaryDiffEq.jl in all examples to reduce latency (#163).\nAllow Fourier and periodic rational derivative operators for BBMBBMEquations1D and SvärdKalischEquations1D (#154).\nAdd BBMEquation1D (#150).","category":"page"},{"location":"changelog_tmp/#Changes-when-updating-to-v0.5-from-v0.4.x","page":"Changelog","title":"Changes when updating to v0.5 from v0.4.x","text":"","category":"section"},{"location":"changelog_tmp/#Changed-2","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog_tmp/","page":"Changelog","title":"Changelog","text":"The BBMBBMVariableEquations1D were removed and BBMBBMEquations1D now supports a bathymetry_type to choose between a flat and a variable bathymetry (#147).\nThe default of bathymetry_type for the SerreGreenNaghdiEquations1D changed from bathymetry_flat to bathymetry_variable (#147).\nbathymetry_type is now a keyword argument for all equations instead of a positional argument (#147).\nThe initial_condition_dingemans for the SerreGreenNaghdiEquations1D and HyperbolicSerreGreenNaghdiEquations1D was changed a bit to be more consistent with the other equations (#147).","category":"page"},{"location":"changelog_tmp/#Changes-in-the-v0.4-lifecycle","page":"Changelog","title":"Changes in the v0.4 lifecycle","text":"","category":"section"},{"location":"changelog_tmp/#Added-3","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog_tmp/","page":"Changelog","title":"Changelog","text":"The SerreGreenNaghdiEquations1D were added for different types of bathymetry (#127, #135).\nThe HyperbolicSerreGreenNaghdiEquations1D were added for different types of bathymetry (#139).\nThe abstract interface AbstractShallowWaterEquations was added to unify several systems such as the SerreGreenNaghdiEquations1D, the BBMBBMEquations1D, and the SvärdKalischEquations1D (#127).\nA new conversion function prim2phys was introduced, defaulting to prim2prim. prim2phys is the default conversion function for plotting.","category":"page"},{"location":"changelog_tmp/#Changes-when-updating-to-v0.4-from-v0.3.x","page":"Changelog","title":"Changes when updating to v0.4 from v0.3.x","text":"","category":"section"},{"location":"changelog_tmp/#Changed-3","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog_tmp/","page":"Changelog","title":"Changelog","text":"Use ArrayPartition from RecursiveArrayTools.jl to store the solution of the ODEProblem (#118).","category":"page"},{"location":"changelog_tmp/#Changes-in-the-v0.3-lifecycle","page":"Changelog","title":"Changes in the v0.3 lifecycle","text":"","category":"section"},{"location":"changelog_tmp/#Added-4","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog_tmp/","page":"Changelog","title":"Changelog","text":"Add possibility to pass vector of Ns to convergence_test (#113).\nPerformance improvements by using factorized matrices for linear systems solves (#108, #112, #114).\nReflecting boundary conditions are added for the BBM-BBM equations (#104, #109).\nFix for the BBMBBMVariableEquations1D, where the still water surface was neglected leading to a bug in the Dingemans setup (#91).","category":"page"},{"location":"changelog_tmp/#Changes-when-updating-to-v0.3-from-v0.2.x","page":"Changelog","title":"Changes when updating to v0.3 from v0.2.x","text":"","category":"section"},{"location":"changelog_tmp/#Changed-4","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog_tmp/","page":"Changelog","title":"Changelog","text":"Add keyword argument start_from when plotting AnalysisCallback (#87).\nManufactured solution for Svärd-Kalisch equations uses a variable bathymetry (#84).","category":"page"},{"location":"changelog_tmp/#Changes-in-the-v0.2-lifecycle","page":"Changelog","title":"Changes in the v0.2 lifecycle","text":"","category":"section"},{"location":"changelog_tmp/#Added-5","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog_tmp/","page":"Changelog","title":"Changelog","text":"Add SummaryCallback (#75).","category":"page"},{"location":"changelog_tmp/#Changes-when-updating-to-v0.2-from-v0.1.x","page":"Changelog","title":"Changes when updating to v0.2 from v0.1.x","text":"","category":"section"},{"location":"changelog_tmp/#Changed-5","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog_tmp/","page":"Changelog","title":"Changelog","text":"The code from the master thesis of Joshua Lampert was separated (#69).\nAdd support for source terms (#65).\nA higher order interpolation is used when plotting the solution at a value x outside the grid (#64).","category":"page"},{"location":"ref-trixibase/#TrixiBase.jl-API","page":"TrixiBase","title":"TrixiBase.jl API","text":"","category":"section"},{"location":"ref-trixibase/#TrixiBase.disable_debug_timings-Tuple{}","page":"TrixiBase","title":"TrixiBase.disable_debug_timings","text":"disable_debug_timings()\n\nDisable all @trixi_timeit timings. The timings should be optimized away, allowing for truly zero-overhead. Enable timings again with enable_debug_timings.\n\nSee also enable_debug_timings, @trixi_timeit.\n\n\n\n\n\n","category":"method"},{"location":"ref-trixibase/#TrixiBase.enable_debug_timings-Tuple{}","page":"TrixiBase","title":"TrixiBase.enable_debug_timings","text":"enable_debug_timings()\n\nEnable all @trixi_timeit timings (default behavior).\n\nSee also disable_debug_timings, @trixi_timeit.\n\n\n\n\n\n","category":"method"},{"location":"ref-trixibase/#TrixiBase.timer-Tuple{}","page":"TrixiBase","title":"TrixiBase.timer","text":"timer()\n\nMain timer for global timing, e.g., to be used with @trixi_timeit.\n\n\n\n\n\n","category":"method"},{"location":"ref-trixibase/#TrixiBase.trixi_include-Tuple{Function, Module, AbstractString}","page":"TrixiBase","title":"TrixiBase.trixi_include","text":"trixi_include([mapexpr::Function=identity,] [mod::Module=Main,] elixir::AbstractString; kwargs...)\n\ninclude the file elixir and evaluate its content in the global scope of module mod. You can override specific assignments in elixir by supplying keyword arguments. Its basic purpose is to make it easier to modify some parameters while running simulations from the REPL. Additionally, this is used in tests to reduce the computational burden for CI while still providing examples with sensible default values for users.\n\nBefore replacing assignments in elixir, the keyword argument maxiters is inserted into calls to solve with it's default value used in the SciML ecosystem for ODEs, see the \"Miscellaneous\" section of the documentation.\n\nThe optional first argument mapexpr can be used to transform the included code before it is evaluated: for each parsed expression expr in elixir, the include function actually evaluates mapexpr(expr). If it is omitted, mapexpr defaults to identity.\n\nExamples\n\njulia> using TrixiBase, Trixi\n\njulia> redirect_stdout(devnull) do\n         trixi_include(@__MODULE__, joinpath(examples_dir(), \"tree_1d_dgsem\", \"elixir_advection_extended.jl\"),\n                       tspan=(0.0, 0.1))\n         sol.t[end]\n       end\n[ Info: You just called `trixi_include`. Julia may now compile the code, please be patient.\n0.1\n\n\n\n\n\n","category":"method"},{"location":"ref-trixibase/#TrixiBase.trixi_include_changeprecision-Tuple{Any, Module, AbstractString}","page":"TrixiBase","title":"TrixiBase.trixi_include_changeprecision","text":"trixi_include_changeprecision(T, [mod::Module=Main,] elixir::AbstractString; kwargs...)\n\ninclude the elixir elixir and evaluate its content in the global scope of module mod. You can override specific assignments in elixir by supplying keyword arguments, similar to trixi_include.\n\nThe only difference to trixi_include is that the precision of floating-point numbers in the included elixir is changed to T. More precisely, the package ChangePrecision.jl is used to convert all Float64 literals, operations like / that produce Float64 results, and functions like ones that return Float64 arrays by default, to the desired type T. See the documentation of ChangePrecision.jl for more details.\n\nThe purpose of this function is to conveniently run a full simulation with Float32, which is orders of magnitude faster on most GPUs than Float64, by just including the elixir with trixi_include_changeprecision(Float32, elixir). Many constructors in the Trixi.jl framework are written in a way that changing all floating-point arguments to Float32 will change the element type to Float32 as well. In TrixiParticles.jl, including an elixir with this macro should be sufficient to run the full simulation with single precision.\n\n\n\n\n\n","category":"method"},{"location":"ref-trixibase/#TrixiBase.@trixi_timeit-Tuple{Any, Any, Any}","page":"TrixiBase","title":"TrixiBase.@trixi_timeit","text":"@trixi_timeit timer() \"some label\" expression\n\nBasically the same as a special case of @timeit_debug from TimerOutputs.jl, but without try ... finally ... end block. Thus, it's not exception-safe, but it also avoids some related performance problems. Since we do not use exception handling in Trixi.jl, that's not really an issue.\n\nAll @trixi_timeit timings can be disabled with disable_debug_timings. The timings should then be optimized away, allowing for truly zero-overhead.\n\nSee also disable_debug_timings, enable_debug_timings.\n\n\n\n\n\n","category":"macro"},{"location":"code_of_conduct/#code-of-conduct","page":"Code of Conduct","title":"Code of Conduct","text":"","category":"section"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"Contributor Covenant Code of ConductOur PledgeWe as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.Our StandardsExamples of behavior that contributes to a positive environment for our community include:Demonstrating empathy and kindness toward other people\nBeing respectful of differing opinions, viewpoints, and experiences\nGiving and gracefully accepting constructive feedback\nAccepting responsibility and apologizing to those affected by our mistakes, and learning from the experience\nFocusing on what is best not just for us as individuals, but for the overall communityExamples of unacceptable behavior include:The use of sexualized language or imagery, and sexual attention or advances of any kind\nTrolling, insulting or derogatory comments, and personal or political attacks\nPublic or private harassment\nPublishing others' private information, such as a physical or email address, without their explicit permission\nOther conduct which could reasonably be considered inappropriate in a professional settingEnforcement ResponsibilitiesCommunity leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.ScopeThis Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.EnforcementInstances of abusive, harassing, or otherwise unacceptable behavior may be reported to Joshua Lampert or Hendrik Ranocha. All complaints will be reviewed and investigated promptly and fairly.All community leaders are obligated to respect the privacy and security of the reporter of any incident.Enforcement GuidelinesCommunity leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:1. CorrectionCommunity Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.2. WarningCommunity Impact: A violation through a single incident or series of actions.Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.3. Temporary BanCommunity Impact: A serious violation of community standards, including sustained inappropriate behavior.Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.4. Permanent BanCommunity Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.Consequence: A permanent ban from any sort of public interaction within the community.AttributionThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 2.0.Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.[homepage]: https://www.contributor-covenant.orgFor answers to common questions about this code of conduct, see the  FAQ.  Translations  are also available there.","category":"page"},{"location":"changelog/#Changelog","page":"Changelog","title":"Changelog","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"DispersiveShallowWater.jl follows the interpretation of semantic versioning (semver) used in the Julia ecosystem. Notable changes will be documented in this file for human readability.","category":"page"},{"location":"changelog/#Changes-in-the-v0.6-lifecycle","page":"Changelog","title":"Changes in the v0.6 lifecycle","text":"","category":"section"},{"location":"changelog/#Added","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Add initial support for ForwardDiff.jl for HyperbolicSerreGreenNaghdiEquations1D and DispersiveShallowWater.jacobian (#185).","category":"page"},{"location":"changelog/#Changes-when-updating-to-v0.6-from-v0.5.x","page":"Changelog","title":"Changes when updating to v0.6 from v0.5.x","text":"","category":"section"},{"location":"changelog/#Changed","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"The keyword argument and function gravity_constant have been changed to gravity (#174).","category":"page"},{"location":"changelog/#Changes-in-the-v0.5-lifecycle","page":"Changelog","title":"Changes in the v0.5 lifecycle","text":"","category":"section"},{"location":"changelog/#Added-2","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Add LinearDispersionRelation and documentation about dispersion (#168).\nReflecting boundary conditions are added for the Svärd-Kalisch equations with alpha = gamma = 0 (#166).\nFix a bug in the upwind discretization of the SvärdKalischEquations1D.\nUse OrdinaryDiffEqTsit5.jl and OrdinaryDiffEqLowStorageRK.jl instead of OrdinaryDiffEq.jl in all examples to reduce latency (#163).\nAllow Fourier and periodic rational derivative operators for BBMBBMEquations1D and SvärdKalischEquations1D (#154).\nAdd BBMEquation1D (#150).","category":"page"},{"location":"changelog/#Changes-when-updating-to-v0.5-from-v0.4.x","page":"Changelog","title":"Changes when updating to v0.5 from v0.4.x","text":"","category":"section"},{"location":"changelog/#Changed-2","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"The BBMBBMVariableEquations1D were removed and BBMBBMEquations1D now supports a bathymetry_type to choose between a flat and a variable bathymetry (#147).\nThe default of bathymetry_type for the SerreGreenNaghdiEquations1D changed from bathymetry_flat to bathymetry_variable (#147).\nbathymetry_type is now a keyword argument for all equations instead of a positional argument (#147).\nThe initial_condition_dingemans for the SerreGreenNaghdiEquations1D and HyperbolicSerreGreenNaghdiEquations1D was changed a bit to be more consistent with the other equations (#147).","category":"page"},{"location":"changelog/#Changes-in-the-v0.4-lifecycle","page":"Changelog","title":"Changes in the v0.4 lifecycle","text":"","category":"section"},{"location":"changelog/#Added-3","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"The SerreGreenNaghdiEquations1D were added for different types of bathymetry (#127, #135).\nThe HyperbolicSerreGreenNaghdiEquations1D were added for different types of bathymetry (#139).\nThe abstract interface AbstractShallowWaterEquations was added to unify several systems such as the SerreGreenNaghdiEquations1D, the BBMBBMEquations1D, and the SvärdKalischEquations1D (#127).\nA new conversion function prim2phys was introduced, defaulting to prim2prim. prim2phys is the default conversion function for plotting.","category":"page"},{"location":"changelog/#Changes-when-updating-to-v0.4-from-v0.3.x","page":"Changelog","title":"Changes when updating to v0.4 from v0.3.x","text":"","category":"section"},{"location":"changelog/#Changed-3","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Use ArrayPartition from RecursiveArrayTools.jl to store the solution of the ODEProblem (#118).","category":"page"},{"location":"changelog/#Changes-in-the-v0.3-lifecycle","page":"Changelog","title":"Changes in the v0.3 lifecycle","text":"","category":"section"},{"location":"changelog/#Added-4","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Add possibility to pass vector of Ns to convergence_test (#113).\nPerformance improvements by using factorized matrices for linear systems solves (#108, #112, #114).\nReflecting boundary conditions are added for the BBM-BBM equations (#104, #109).\nFix for the BBMBBMVariableEquations1D, where the still water surface was neglected leading to a bug in the Dingemans setup (#91).","category":"page"},{"location":"changelog/#Changes-when-updating-to-v0.3-from-v0.2.x","page":"Changelog","title":"Changes when updating to v0.3 from v0.2.x","text":"","category":"section"},{"location":"changelog/#Changed-4","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Add keyword argument start_from when plotting AnalysisCallback (#87).\nManufactured solution for Svärd-Kalisch equations uses a variable bathymetry (#84).","category":"page"},{"location":"changelog/#Changes-in-the-v0.2-lifecycle","page":"Changelog","title":"Changes in the v0.2 lifecycle","text":"","category":"section"},{"location":"changelog/#Added-5","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Add SummaryCallback (#75).","category":"page"},{"location":"changelog/#Changes-when-updating-to-v0.2-from-v0.1.x","page":"Changelog","title":"Changes when updating to v0.2 from v0.1.x","text":"","category":"section"},{"location":"changelog/#Changed-5","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"The code from the master thesis of Joshua Lampert was separated (#69).\nAdd support for source terms (#65).\nA higher order interpolation is used when plotting the solution at a value x outside the grid (#64).","category":"page"},{"location":"license/#License","page":"License","title":"License","text":"","category":"section"},{"location":"license/","page":"License","title":"License","text":"MIT License","category":"page"},{"location":"license/","page":"License","title":"License","text":"Copyright (c) 2023-present Joshua Lampert <joshua.lampert@uni-hamburg.de> and contributors","category":"page"},{"location":"license/","page":"License","title":"License","text":"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","category":"page"},{"location":"license/","page":"License","title":"License","text":"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","category":"page"},{"location":"license/","page":"License","title":"License","text":"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"overview/#Running-a-simulation","page":"Overview","title":"Running a simulation","text":"","category":"section"},{"location":"overview/#Introduction","page":"Overview","title":"Introduction","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"In this tutorial we describe how to numerically solve the BBM-BBM (Benjamin-Bona-Mahony) equations with variable bottom topography in one dimension, which has been proposed in [IsrawiKalischKatsaounisMitsotakis2021] for two spatial dimensions. The equations describe a dispersive shallow water model, i.e. they extend the well-known shallow water equations in the sense that dispersion is modeled. The shallow water equations are a system of first order hyperbolic partial differential equations that can be written in the form of a balance law. In contrast, the BBM-BBM equations additionally include third-order mixed derivatives. In primitive variables q = (eta v) they can be written as:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"beginaligned\n  eta_t + ((eta + D)v)_x - frac16(D^2eta_xt)_x = 0\n  v_t + geta_x + left(frac12v^2right)_x - frac16(D^2v_t)_xx = 0\nendaligned","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Here, eta = h + b describes the total water height, h the water height above the bottom topography (bathymetry), b = eta_0 - D the bathymetry and v the velocity in horizontal direction. Here, eta_0 is a reference water height also called still water height. In the case of the BBM-BBM equations, eta_0 is usually taken to be 0. The gravitational acceleration is denoted as g. A sketch of the water height and the bathymetry can be found below.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"(Image: water height and bathymetry)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"In order to conduct a numerical simulation with DispersiveShallowWater.jl, we perform the following steps.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"First, we load the necessary libraries:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using DispersiveShallowWater, OrdinaryDiffEqTsit5","category":"page"},{"location":"overview/#Define-physical-setup","page":"Overview","title":"Define physical setup","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"As a first step of a numerical simulation, we define the physical setup we want to solve. This includes the set of equations, potentially including physical parameters, initial and boundary conditions as well as the domain. In the following example, the initial condition describes a traveling wave that moves towards a beach, which is modeled by a linearly increasing bathymetry.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"equations = BBMBBMEquations1D(bathymetry_type = bathymetry_variable, gravity = 9.81)\n\nfunction initial_condition_shoaling(x, t, equations::BBMBBMEquations1D, mesh)\n    A = 0.07 # amplitude of wave\n    x0 = -30 # initial center\n    eta = A * exp(-0.1*(x - x0)^2)\n    v = 0\n    D = x <= 0.0 ? 0.7 : 0.7 - 1/50 * x\n    return SVector(eta, v, D)\nend\n\ninitial_condition = initial_condition_shoaling\nboundary_conditions = boundary_condition_periodic\n\ncoordinates_min = -130.0\ncoordinates_max = 20.0\nN = 512\nmesh = Mesh1D(coordinates_min, coordinates_max, N + 1)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The first line specifies that we want to solve the BBM-BBM equations with variable bathymetry using a gravitational acceleration g = 981. Afterwards, we define the initial condition, which is described as a function with the spatial variable x, the time t, the equations and a mesh as parameters. If an analytical solution is available, the time variable t can be used, and the initial condition can serve as an analytical solution to be compared with the numerical solution. Otherwise, you can just keep the time variable unused. An initial condition in DispersiveShallowWater.jl is supposed to return an SVector holding the values for each of the unknown variables. Since the bathymetry is treated as a variable (with time derivative 0) for convenience, we need to provide the value for the primitive variables eta and v as well as for D.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Next, we choose periodic boundary conditions. DispersiveShallowWater.jl also supports reflecting boundary conditions for the BBMBBMEquations1D, see boundary_condition_reflecting. Lastly, we define the physical domain as the interval from -130 to 20 and we choose 512 intermediate nodes. The mesh is homogeneous, i.e. the distance between each two nodes is constant. We choose the left boundary very far to the left in order to avoid an interaction of the left- and right-traveling waves.","category":"page"},{"location":"overview/#Define-numerical-solver","page":"Overview","title":"Define numerical solver","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"In the next step, we build a Semidiscretization that bundles all ingredients for the spatial discretization of the model. Especially, we need to define a Solver. The simplest way to define a solver is to call the constructor by providing the mesh and a desired order of accuracy. In the following example, we use an accuracy order of 4. The default constructor simply creates periodic first- and second-derivative central finite difference summation-by-parts (SBP) operators of the provided order of accuracy. How to use other summation-by-parts operators, is described in the section on how to customize the solver. Note that for non-periodic boundary conditions, the solver also needs to be created with non-periodic operators, see, e.g. examples/bbm_bbm_1d/bbm_bbm_1d_basic_reflecting.jl.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"solver = Solver(mesh, 4)\n\nsemi = Semidiscretization(mesh, equations, initial_condition, solver, boundary_conditions = boundary_conditions)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Finally, we put the mesh, the equations, the initial_condition, the solver and the boundary_conditions together in a semidiscretization semi.","category":"page"},{"location":"overview/#Solve-system-of-ordinary-differential-equations","page":"Overview","title":"Solve system of ordinary differential equations","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Once we have obtained a semidiscretization, we can solve the resulting system of ordinary differential equations. To do so, we specify the time interval that we want to simulate and obtain an ODEProblem from the SciML ecosystem for ordinary differential equations by calling semidiscretize on the semidiscretization and the time span. Additionally, we can analyze the numerical solution using an AnalysisCallback. The analysis includes computing the L^2 error and L^infty error of the different solution's variables compared to the initial condition (or, if available, at the same time analytical solution). Additional errors can be passed by the keyword argument extra_analysis_errors. Additional integral quantities that should be analyzed can be passed by keyword argument extra_analysis_integrals. In this example we pass the conservation_error, which computes the temporal change of the total amount (i.e. integral) of the different variables over time. In addition, the integrals of the total water height eta waterheight_total, the velocity and the entropy are computed and saved for each time step. The total water height and the total velocity are linear invariants of the BBM-BBM equations, i.e. they do not change over time. The total entropy","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"mathcal E(t eta v) = frac12int_Omega geta^2 + (eta + D)v^2textrmdx","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"is a nonlinear invariant and should be constant over time as well. During the simulation, the AnalysisCallback will print the results to the terminal.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Finally, the ode can be solved using the interface from OrdinaryDiffEq.jl. This means, we can specify a time-stepping scheme we want to use the tolerances for the adaptive time-stepping and the time values, where the solution values should be saved. In this case, we use the adaptive explicit Runge-Kutta method Tsit5 by Tsitouras of order 5(4), which is implemented in the subpackage OrdinaryDiffEqTsit5.jl. If you want to use other time-stepping schemes, you can install the respective subpackage or the whole package OrdinaryDiffEq.jl, which will install every available solver. Here, we save the solution at 100 equidistant points.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"tspan = (0.0, 25.0)\node = semidiscretize(semi, tspan)\nanalysis_callback = AnalysisCallback(semi; interval = 10,\n                                     extra_analysis_errors = (:conservation_error,),\n                                     extra_analysis_integrals = (waterheight_total,\n                                                                 velocity, entropy),\n                                     io = devnull)\ncallbacks = CallbackSet(analysis_callback)\n\nsaveat = range(tspan..., length = 100)\nsol = solve(ode, Tsit5(), abstol = 1e-7, reltol = 1e-7,\n            save_everystep = false, callback = callbacks, saveat = saveat)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"After solving the equations, sol contains the solution for each of the three variables at every spatial point for each of the 100 points in time. The errors and integrals recorded by the AnalysisCallback can be obtained as NamedTuples by errors(analysis_callback) and integrals(analysis_callback).","category":"page"},{"location":"overview/#visualize_results","page":"Overview","title":"Visualize results","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"After running the simulation, the results can be visualized using Plots.jl, which needs to be imported first. Then, we can plot the solution at the final time by calling plot on a Pair of the Semidiscretization and the corresponding ODESolution sol. The result is depicted in the following picture.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using Plots\n\nplot(semi => sol)\nsavefig(\"shoaling_solution.png\") # hide\nnothing # hide","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"(Image: shoaling solution)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"By default, this will plot the bathymetry, but not the initial (analytical) solution. You can adjust this by passing the boolean values plot_bathymetry (if true always plot to first subplot) and plot_initial. You can also provide a conversion function that converts the solution. A conversion function should take the values of the primitive variables q at one node, and the equations as input and should return an SVector of any length as output. For a user defined conversion function, there should also exist a function varnames(conversion, equations) that returns a Tuple of the variable names used for labelling. The conversion function can, e.g., be prim2cons or waterheight_total if one only wants to plot the total water height. The resulting plot will have one subplot for each of the returned variables of the conversion variable. By default, the conversion function is just prim2phys, which computes the physical variables from the primitive ones, i.e., the identity for most equations.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Plotting an animation over time can, e.g., be done by the following command, which uses step to plot the solution at a specific time step.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"anim = @animate for step in 1:length(sol.u)\n    plot(semi => sol, plot_initial = true, conversion = waterheight_total, step = step, xlim = (-50, 20), ylims = (-0.8, 0.1))\nend\ngif(anim, \"shoaling_solution.gif\", fps = 25)\nnothing # hide","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"(Image: shoaling solution)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"It is also possible to plot the solution variables at a fixed spatial point over time by calling plot(semi => sol, x) for some x-value, see plot_examples.jl from the reproducibility repository of the master thesis of Joshua Lampert for some examples.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Often, it is interesting to have a look at how the quantities that are recorded by the AnalysisCallback evolve in time. To this end, you can plot the AnalysisCallback by","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"plot(analysis_callback)\nsavefig(\"analysis_callback.png\") # hide\nnothing # hide","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"This creates the following figure:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"(Image: analysis callback)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"You can see that the linear invariants int_Omegaetatextrmdx and int_Omega vtextrmdx are indeed conserved exactly. The entropy, however, starts growing at around t = 17  and rises up to approximately 5e-5. This is because of the fact that, during the time integration, a nonlinear invariant is not necessarily conserved, even if the semidiscretization conserves the quantity exactly. How to obtain a fully-discrete structure-preserving numerical scheme is explained in the following section.","category":"page"},{"location":"overview/#Use-entropy-conserving-time-integration","page":"Overview","title":"Use entropy-conserving time integration","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"To obtain entropy-conserving time-stepping schemes DispersiveShallowWater.jl uses the relaxation method introduced in [Ketcheson2019] and further developed in [RanochaSayyariDalcinParsaniKetcheson2020]. The relaxation method is implemented as a RelaxationCallback, which takes a function representing the conserved quantity as the keyword argument invariant. Therefore, we can run the same example as above, but using relaxation on the entropy by simply adding another callback to the CallbackSet:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"analysis_callback = AnalysisCallback(semi; interval = 10,\n                                     extra_analysis_errors = (:conservation_error,),\n                                     extra_analysis_integrals = (waterheight_total,\n                                                                 velocity, entropy),\n                                     io = devnull)\nrelaxation_callback = RelaxationCallback(invariant = entropy)\ncallbacks = CallbackSet(relaxation_callback, analysis_callback)\nsol = solve(ode, Tsit5(), abstol = 1e-7, reltol = 1e-7,\n            save_everystep = false, callback = callbacks, saveat = saveat)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"When you use both, an AnalysisCallback and a RelaxationCallback, note that the relaxation_callback needs to come first inside the CallbackSet as it needs to be invoked prior to the analysis_callback, such that the analysis_callback analyzes the solution with the already updated values.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Plotting the analysis_callback again, we can see that now also the entropy is conserved up to machine precision.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"plot(analysis_callback, ylims = (-5e-16, 5e-16))\nsavefig(\"analysis_callback_relaxation.png\") # hide\nnothing # hide","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"(Image: analysis callback relaxation)","category":"page"},{"location":"overview/#customize_solver","page":"Overview","title":"Customize solver","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"In the semidiscretization created above, we used the default SBP operators, which are periodic finite difference operators. Using different SBP operators for the semidiscretization can be done leveraging SummationByPartsOperators.jl, which needs to be imported first:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using SummationByPartsOperators: legendre_derivative_operator, UniformPeriodicMesh1D, couple_discontinuously, PeriodicUpwindOperators","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"As an example, let us create a semidiscretization based on discontinuous Galerkin (DG) upwind operators. A semidiscretization implemented in DispersiveShallowWater.jl needs one first-derivative and one second-derivative SBP operator. To build the first-derivative operator, we first create a LegendreDerivativeOperator with polynomial degree 3 on a reference element [-1.0, 1.0] and a UniformPeriodicMesh1D for the coupling.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"mesh = Mesh1D(coordinates_min, coordinates_max, N)\naccuracy_order = 4\nD_legendre = legendre_derivative_operator(-1.0, 1.0, accuracy_order)\nuniform_mesh = UniformPeriodicMesh1D(mesh.xmin, mesh.xmax, div(mesh.N, accuracy_order))","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Upwind DG operators in negative, central and positive operators can be obtained by couple_discontinuously","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"central = couple_discontinuously(D_legendre, uniform_mesh)\nminus = couple_discontinuously(D_legendre, uniform_mesh, Val(:minus))\nplus = couple_discontinuously(D_legendre, uniform_mesh, Val(:plus))\nD1 = PeriodicUpwindOperators(minus, central, plus)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"In order to still have an entropy-conserving semidiscretization the second-derivative SBP operator needs to be","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using SparseArrays: sparse\nD2 = sparse(plus) * sparse(minus)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The Solver object can now be created by passing the two SBP operators to the constructor, which, in turn, can be used to construct a Semidiscretization:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"solver = Solver(D1, D2)\nsemi = Semidiscretization(mesh, equations, initial_condition, solver, boundary_conditions = boundary_conditions)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"As before, we can run the simulation by","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"analysis_callback = AnalysisCallback(semi; interval = 10,\n                                     extra_analysis_errors = (:conservation_error,),\n                                     extra_analysis_integrals = (waterheight_total,\n                                                                 velocity, entropy),\n                                     io = devnull)\nrelaxation_callback = RelaxationCallback(invariant = entropy)\ncallbacks = CallbackSet(relaxation_callback, analysis_callback)\nsol = solve(ode, Tsit5(), abstol = 1e-7, reltol = 1e-7,\n            save_everystep = false, callback = callbacks, saveat = saveat)\nanim = @animate for step in 1:length(sol.u)\n    plot(semi => sol, plot_initial = true, conversion = waterheight_total, step = step, xlim = (-50, 20), ylims = (-0.8, 0.1))\nend\ngif(anim, \"shoaling_solution_dg.gif\", fps = 25)\nnothing # hide","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"(Image: shoaling solution DG)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"For more details see also the documentation of SummationByPartsOperators.jl","category":"page"},{"location":"overview/#Additional-resources","page":"Overview","title":"Additional resources","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Some more examples sorted by the simulated equations can be found in the examples/ subdirectory. Especially, in examples/svaerd_kalisch_1d/ you can find Julia scripts that solve the SvaerdKalischEquations1D that were not covered in this tutorial. The same steps as described above, however, apply in the same way to these equations. Attention must be paid for these equations because they do not conserve the classical total entropy mathcal E, but a modified entropy hatmathcal E, available as entropy_modified.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"More examples, especially focussing on plotting, can be found in the scripts create_figures.jl and plot_examples.jl from the reproducibility repository of the master thesis of Joshua Lampert.","category":"page"},{"location":"overview/#References","page":"Overview","title":"References","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"[IsrawiKalischKatsaounisMitsotakis2021]: Israwi, Kalisch, Katsaounis, Mitsotakis (2021). A regularized shallow-water waves system with slip-wall boundary conditions in a basin: theory and numerical analysis. DOI: 10.1088/1361-6544/ac3c29","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"[Ketcheson2019]: Ketcheson (2019): Relaxation Runge-Kutta Methods: Conservation and stability for Inner-Product Norms. DOI: 10.1137/19M1263662","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"[RanochaSayyariDalcinParsaniKetcheson2020]: Ranocha, Sayyari, Dalcin, Parsani, Ketcheson (2020): Relaxation Runge–Kutta Methods: Fully-Discrete Explicit Entropy-Stable Schemes for the Compressible Euler and Navier–Stokes Equations DOI: 10.1137/19M1263480","category":"page"},{"location":"ref/#DispersiveShallowWater.jl-API","page":"DispersiveShallowWater","title":"DispersiveShallowWater.jl API","text":"","category":"section"},{"location":"ref/#DispersiveShallowWater.DispersiveShallowWater","page":"DispersiveShallowWater","title":"DispersiveShallowWater.DispersiveShallowWater","text":"DispersiveShallowWater\n\nDispersiveShallowWater.jl is a Julia package that implements structure-preserving numerical methods for dispersive shallow water models. It provides provably conservative, entropy-conserving, and well-balanced numerical schemes for some dispersive shallow water models.\n\nThe semidiscretizations are based on summation-by-parts (SBP) operators, which are implemented in SummationByPartsOperators.jl. To obtain fully discrete schemes, the time integration methods from OrdinaryDiffEq.jl are used to solve the resulting ordinary differential equations. Fully discrete entropy-conservative methods can be obtained by using the relaxation method provided by DispersiveShallowWater.jl.\n\nSee also: DispersiveShallowWater.jl\n\n\n\n\n\n","category":"module"},{"location":"ref/#Equations","page":"DispersiveShallowWater","title":"Equations","text":"","category":"section"},{"location":"ref/#DispersiveShallowWater.BBMEquation1D","page":"DispersiveShallowWater","title":"DispersiveShallowWater.BBMEquation1D","text":"BBMEquation1D(; gravity, D = 1.0, eta0 = 0.0, split_form = true)\n\nBBM (Benjamin–Bona–Mahony) equation in one spatial dimension. The equation is given by\n\nbeginaligned\n  eta_t + sqrtgDeta_x + frac32sqrtfracgDetaeta_x - frac16D^2eta_xxt = 0\nendaligned\n\nThe unknown quantity of the BBM equation is the total water height eta. The gravitational acceleration gravity is denoted by g and the constant bottom topography (bathymetry) b = eta_0 - D, where eta_0 is the constant still-water surface and D the still-water depth. The water height above the bathymetry is therefore given by h = eta - eta_0 + D. The BBM equation is only implemented for eta_0 = 0.\n\nThe equations only support a flat bathymetry.\n\nThe BBM equation is first described in Benjamin, Bona, and Mahony (1972). The semidiscretization implemented here is developed in Ranocha, Mitsotakis, and Ketcheson (2020) for split_form = true and in Linders, Ranocha, and Birken (2023) for split_form = false. If split_form is true, a split form in the semidiscretization is used, which conserves\n\nthe total water mass (integral of h) as a linear invariant\na quadratic invariant (integral of 12eta(eta - 16D^2eta_xx) or for periodic boundary conditions equivalently 12(eta^2 + 16D^2eta_x^2)), which is called here energy_total_modified (and entropy_modified) because it contains derivatives of the solution\n\nfor periodic boundary conditions. If split_form is false the semidiscretization conserves\n\nthe total water mass (integral of h) as a linear invariant\nthe Hamiltonian (integral of 14sqrtgDeta^3 + 12sqrtgDeta^2) (see hamiltonian)\n\nfor periodic boundary conditions.\n\nThomas B. Benjamin, Jerry L. Bona and John J. Mahony (1972) Model equations for long waves in nonlinear dispersive systems DOI: 10.1098/rsta.1972.0032\nHendrik Ranocha, Dimitrios Mitsotakis and David I. Ketcheson (2020) A Broad Class of Conservative Numerical Methods for Dispersive Wave Equations DOI: 10.4208/cicp.OA-2020-0119\nViktor Linders, Hendrik Ranocha and Philipp Birken (2023) Resolving entropy growth from iterative methods DOI: 10.1007/s10543-023-00992-w\n\n\n\n\n\n","category":"type"},{"location":"ref/#DispersiveShallowWater.energy_total_modified!-Tuple{Any, Any, BBMEquation1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.energy_total_modified!","text":"energy_total_modified!(e, q_global, equations::BBMEquation1D, cache)\n\nReturn the modified total energy e of the primitive variables q_global for the BBMEquation1D. The energy_total_modified is a conserved quantity (for periodic boundary conditions).\n\nIt is given by\n\nfrac12 eta(eta - frac16D^2eta_xx)\n\nq_global is a vector of the primitive variables at ALL nodes. cache needs to hold the SBP operators used by the solver.\n\nSee also energy_total_modified.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.hamiltonian!-Tuple{Any, Any, BBMEquation1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.hamiltonian!","text":"hamiltonian!(H, q_global, equations::BBMEquation1D, cache)\n\nReturn the Hamiltonian H of the primitive variables q_global for the BBMEquation1D. The Hamiltonian is given by\n\nfrac14sqrtfracgDeta^3 + frac12sqrtgDeta^2\n\nq_global is a vector of the primitive variables at ALL nodes.\n\nSee also hamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_convergence_test-Tuple{Any, Any, BBMEquation1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::BBMEquation1D, mesh)\n\nA travelling-wave solution used for convergence tests in a periodic domain, here generalized for dimensional variables.\n\nSee section 4.1.3 in (there is an error in paper: it should be sech^2 instead of cosh):\n\nHendrik Ranocha, Dimitrios Mitsotakis and David I. Ketcheson (2020) A Broad Class of Conservative Numerical Methods for Dispersive Wave Equations DOI: 10.4208/cicp.OA-2020-0119\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_manufactured-Tuple{Any, Any, BBMEquation1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_manufactured","text":"initial_condition_manufactured(x, t, equations::BBMEquation1D, mesh)\n\nA smooth manufactured solution in combination with source_terms_manufactured.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.source_terms_manufactured-Tuple{Any, Any, Any, BBMEquation1D}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.source_terms_manufactured","text":"source_terms_manufactured(q, x, t, equations::BBMEquation1D, mesh)\n\nA smooth manufactured solution in combination with initial_condition_manufactured.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.BBMBBMEquations1D","page":"DispersiveShallowWater","title":"DispersiveShallowWater.BBMBBMEquations1D","text":"BBMBBMEquations1D(; bathymetry_type = bathymetry_variable,\n                  gravity, eta0 = 0.0)\n\nBBM-BBM (Benjamin–Bona–Mahony) system in one spatial dimension. The equations for flat bathymetry are given by\n\nbeginaligned\n  eta_t + ((eta + D)v)_x - frac16D^2eta_xxt = 0\n  v_t + geta_x + left(frac12v^2right)_x - frac16D^2v_xxt = 0\nendaligned\n\nThe unknown quantities of the BBM-BBM equations are the total water height eta and the velocity v. The gravitational acceleration gravity is denoted by g and the constant bottom topography (bathymetry) b = eta_0 - D. The water height above the bathymetry is therefore given by h = eta - eta_0 + D. The BBM-BBM equations are only implemented for eta_0 = 0.\n\nTwo types of bathymetry_type are supported:\n\nbathymetry_flat: flat bathymetry (typically b = 0 everywhere)\nbathymetry_variable: general variable bathymetry\n\nFor the general case of variable vathymetry the BBM-BBM equations are\n\nbeginaligned\n  eta_t + ((eta + D)v)_x - frac16(D^2eta_xt)_x = 0\n  v_t + geta_x + left(frac12v^2right)_x - frac16(D^2v_t)_xx = 0\nendaligned\n\nOne reference for the BBM-BBM system can be found in Bona et al. (1998). The semidiscretization implemented here was developed for flat bathymetry in Ranocha et al. (2020) and generalized for a variable bathymetry in Lampert and Ranocha (2024). It conserves\n\nthe total water mass (integral of h) as a linear invariant\nthe total velocity (integral of v) as a linear invariant for flat bathymetry\nthe total energy\n\nfor periodic boundary conditions (see Lampert, Ranocha). For reflecting boundary conditions, the semidiscretization conserves\n\nthe total water (integral of h) as a linear invariant\nthe total energy.\n\nAdditionally, it is well-balanced for the lake-at-rest stationary solution, see Lampert and Ranocha (2024).\n\nJerry L. Bona, Min Chen (1998) A Boussinesq system for two-way propagation of nonlinear dispersive waves DOI: 10.1016/S0167-2789(97)00249-2\nHendrik Ranocha, Dimitrios Mitsotakis, David I. Ketcheson (2020) A Broad Class of Conservative Numerical Methods for Dispersive Wave Equations DOI: 10.4208/cicp.OA-2020-0119\nJoshua Lampert, Hendrik Ranocha (2024) Structure-Preserving Numerical Methods for Two Nonlinear Systems of Dispersive Wave Equations DOI: 10.48550/arXiv.2402.16669\n\n\n\n\n\n","category":"type"},{"location":"ref/#DispersiveShallowWater.initial_condition_convergence_test-Tuple{Any, Any, BBMBBMEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::BBMBBMEquations1D, mesh)\n\nA traveling-wave solution used for convergence tests in a periodic domain. The bathymetry is constant.\n\nFor details see Example 5 in Section 3 from (here adapted for dimensional equations):\n\nMin Chen (1997) Exact Traveling-Wave Solutions to Bidirectional Wave Equations DOI: 10.1023/A:1026667903256\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_dingemans-Tuple{Any, Any, BBMBBMEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_dingemans","text":"initial_condition_dingemans(x, t, equations::BBMBBMEquations1D, mesh)\n\nThe initial condition that uses the dispersion relation of the Euler equations to approximate waves generated by a wave maker as it is done by experiments of Dingemans. The topography is a trapezoidal.\n\nwarning: Translation of water height\nThe initial condition for the water height is translated to be around 0, which is needed for the simulation because the BBMBBMEquations1D are only implemented for eta_0 = 0.\n\nReferences:\n\nMagnus Svärd, Henrik Kalisch (2023) A novel energy-bounded Boussinesq model and a well-balanced and stable numerical discretization arXiv: 2302.09924\nMaarten W. Dingemans (1994) Comparison of computations with Boussinesq-like models and laboratory measurements link\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_manufactured-Tuple{Any, Any, BBMBBMEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_manufactured","text":"initial_condition_manufactured(x, t, equations::BBMBBMEquations1D, mesh)\n\nA smooth manufactured solution in combination with source_terms_manufactured.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_manufactured_reflecting-Tuple{Any, Any, BBMBBMEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_manufactured_reflecting","text":"initial_condition_manufactured_reflecting(x, t, equations::BBMBBMEquations1D, mesh)\n\nA smooth manufactured solution for reflecting boundary conditions in combination with source_terms_manufactured_reflecting.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.source_terms_manufactured-Tuple{Any, Any, Any, BBMBBMEquations1D}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.source_terms_manufactured","text":"source_terms_manufactured(q, x, t, equations::BBMBBMEquations1D, mesh)\n\nA smooth manufactured solution in combination with initial_condition_manufactured.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.source_terms_manufactured_reflecting-Tuple{Any, Any, Any, BBMBBMEquations1D}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.source_terms_manufactured_reflecting","text":"source_terms_manufactured_reflecting(q, x, t, equations::BBMBBMEquations1D, mesh)\n\nA smooth manufactured solution for reflecting boundary conditions in combination with initial_condition_manufactured_reflecting.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.bathymetry_flat","page":"DispersiveShallowWater","title":"DispersiveShallowWater.bathymetry_flat","text":"bathymetry_flat = DispersiveShallowWater.BathymetryFlat()\n\nA singleton struct indicating a flat bathymetry.\n\nSee also bathymetry_mild_slope and bathymetry_variable.\n\n\n\n\n\n","category":"constant"},{"location":"ref/#DispersiveShallowWater.bathymetry_mild_slope","page":"DispersiveShallowWater","title":"DispersiveShallowWater.bathymetry_mild_slope","text":"bathymetry_mild_slope = DispersiveShallowWater.BathymetryMildSlope()\n\nA singleton struct indicating a variable bathymetry with mild-slope approximation. Typically, this means that some terms like b_x^2 are neglected.\n\nSee also bathymetry_flat and bathymetry_variable.\n\n\n\n\n\n","category":"constant"},{"location":"ref/#DispersiveShallowWater.bathymetry_variable","page":"DispersiveShallowWater","title":"DispersiveShallowWater.bathymetry_variable","text":"bathymetry_variable = DispersiveShallowWater.BathymetryVariable()\n\nA singleton struct indicating a variable bathymetry (without mild-slope approximation).\n\nSee also bathymetry_flat and bathymetry_mild_slope.\n\n\n\n\n\n","category":"constant"},{"location":"ref/#DispersiveShallowWater.AbstractEquations","page":"DispersiveShallowWater","title":"DispersiveShallowWater.AbstractEquations","text":"AbstractEquations{NDIMS, NVARS}\n\nAn abstract supertype of specific equations such as the BBM-BBM equations. The type parameters encode the number of spatial dimensions (NDIMS) and the number of primary variables (NVARS) of the physics model.\n\nSee also AbstractShallowWaterEquations.\n\n\n\n\n\n","category":"type"},{"location":"ref/#DispersiveShallowWater.AbstractShallowWaterEquations","page":"DispersiveShallowWater","title":"DispersiveShallowWater.AbstractShallowWaterEquations","text":"AbstractShallowWaterEquations{NDIMS, NVARS}\n\nAn abstract supertype of all equation system that contain the classical shallow water equations as a subsystem, e.g., the BBMBBMEquations1D, the SvaerdKalischEquations1D, and the SerreGreenNaghdiEquations1D. In 1D, the shallow water equations with flat bathymetry are given by\n\nbeginaligned\n  h_t + (h v)_x = 0\n  h v_t + frac12 g (h^2)_x + frac12 h (v^2)_x = 0\nendaligned\n\nwhere h is the waterheight, v the velocity, and g the gravity.\n\n\n\n\n\n","category":"type"},{"location":"ref/#DispersiveShallowWater.bathymetry-Tuple{Any, DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.bathymetry","text":"bathymetry(q, equations)\n\nReturn the bathymetry of the primitive variables q for a given set of equations.\n\nq is a vector of the primitive variables at a single node, i.e., a vector of the correct length nvariables(equations).\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.cons2prim-Tuple{Any, AbstractShallowWaterEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.cons2prim","text":"cons2prim(u, equations)\n\nConvert the conserved variables u to the primitive variables for a given set of equations. u is a vector type of the correct length nvariables(equations). Notice the function doesn't include any error checks for the purpose of efficiency, so please make sure your input is correct. The inverse conversion is performed by prim2cons.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.default_analysis_errors-Tuple{DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.default_analysis_errors","text":"default_analysis_errors(equations)\n\nDefault analysis errors used by the AnalysisCallback.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.default_analysis_integrals-Tuple{DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.default_analysis_integrals","text":"default_analysis_integrals(equations)\n\nDefault analysis integrals used by the AnalysisCallback.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.discharge-Tuple{Any, DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.discharge","text":"discharge(q, equations)\n\nSee momentum.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.eachvariable-Tuple{DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.eachvariable","text":"eachvariable(equations::AbstractEquations)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the variables in equations. In particular, not the variables themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.energy_total-Tuple{Any, AbstractShallowWaterEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.energy_total","text":"energy_total(q, equations)\n\nReturn the total energy of the primitive variables q for a given set of equations. For all AbstractShallowWaterEquations, the total energy is given by the sum of the kinetic and potential energy of the shallow water subsystem, i.e.,\n\nfrac12 h v^2 + frac12 g eta^2\n\nin 1D, where h is the waterheight, eta = h + b the waterheight_total, v the velocity, and g the gravity.\n\nq is a vector of the primitive variables at a single node, i.e., a vector of the correct length nvariables(equations).\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.energy_total_modified!-Tuple{Any, Any, DispersiveShallowWater.AbstractEquations, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.energy_total_modified!","text":"energy_total_modified!(e, q_global, equations, cache)\n\nIn-place version of energy_total_modified.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.energy_total_modified-Tuple{Any, DispersiveShallowWater.AbstractEquations, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.energy_total_modified","text":"energy_total_modified(q_global, equations, cache)\n\nReturn the modified total energy of the primitive variables q_global for the equations. This modified total energy is a conserved quantity and can contain additional terms compared to the usual energy_total. For example, for the SvaerdKalischEquations1D and the SerreGreenNaghdiEquations1D, it contains additional terms depending on the derivative of the velocity v_x modeling non-hydrostatic contributions. For equations which are not AbstractShallowWaterEquations, the modified total energy does not have to be an extension of the usual energy_total and does not have to be related to a physical energy. However, it is still a conserved quantity for appropriate boundary conditions and may contain derivatives of the solution.\n\nq_global is a vector of the primitive variables at ALL nodes. cache needs to hold the SBP operators used by the solver if non-hydrostatic terms are present.\n\nInternally, this function allocates a vector for the output and calls DispersiveShallowWater.energy_total_modified!.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.entropy-Tuple{Any, AbstractShallowWaterEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.entropy","text":"entropy(q, equations)\n\nReturn the entropy of the primitive variables q for a given set of equations. For all AbstractShallowWaterEquations, the entropy is just the energy_total.\n\nq is a vector of the primitive variables at a single node, i.e., a vector of the correct length nvariables(equations).\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.entropy_modified!-NTuple{4, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.entropy_modified!","text":"entropy_modified!(e, q_global, equations, cache)\n\nIn-place version of entropy_modified.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.entropy_modified-Tuple{Any, DispersiveShallowWater.AbstractEquations, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.entropy_modified","text":"entropy_modified(q_global, equations, cache)\n\nAlias for energy_total_modified.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.get_name-Tuple{DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.get_name","text":"get_name(equations::AbstractEquations)\n\nReturn the canonical, human-readable name for the given system of equations.\n\nExamples\n\njulia> DispersiveShallowWater.get_name(BBMBBMEquations1D(gravity=1.0))\n\"BBMBBMEquations1D-BathymetryVariable\"\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.gravity-Tuple{DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.gravity","text":"gravity(equations)\n\nReturn the gravitational acceleration g for a given set of equations.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.hamiltonian-Tuple{Any, DispersiveShallowWater.AbstractEquations, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.hamiltonian","text":"hamiltonian(q_global, equations, cache)\n\nReturn the Hamiltonian of the primitive variables q_global for the equations. The Hamiltonian is a conserved quantity and may contain derivatives of the solution.\n\nq_global is a vector of the primitive variables at ALL nodes. cache needs to hold the SBP operators used by the solver if non-hydrostatic terms are present.\n\nInternally, this function allocates a vector for the output and calls DispersiveShallowWater.hamiltonian!.\n\nnote: Note\nThis function is not necessarily implemented for all equations. See DispersiveShallowWater.hamiltonian! for further details of equations supporting it.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.hyperbolic_approximation_limit-Tuple{DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.hyperbolic_approximation_limit","text":"DispersiveShallowWater.hyperbolic_approximation_limit(equations)\n\nIf the equations are a hyperbolic approximation of another set of equations, return the equations of the limit system. Otherwise, return the input equations.\n\nSee also is_hyperbolic_appproximation and prim2phys.\n\nnote: Implementation details\nThis function is mostly used for some internal dispatch. For example, it allows to return a reduced set of variables from initial conditions for hyperbolic approximations.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_dingemans-Tuple{Any, Any, AbstractShallowWaterEquations, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_dingemans","text":"initial_condition_dingemans(x, t, equations::AbstractShallowWaterEquations, mesh)\n\nThe initial condition that uses the dispersion relation of the Euler equations to approximate waves generated by a wave maker as it is done by experiments of Dingemans. The topography is a trapezoidal. It is assumed that equations.eta0 = 0.8.\n\nReferences:\n\nMagnus Svärd, Henrik Kalisch (2023) A novel energy-bounded Boussinesq model and a well-balanced and stable numerical discretization arXiv: 2302.09924\nMaarten W. Dingemans (1994) Comparison of computations with Boussinesq-like models and laboratory measurements link\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_discontinuous_well_balancedness-Tuple{Any, Any, AbstractShallowWaterEquations, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_discontinuous_well_balancedness","text":"initial_condition_discontinuous_well_balancedness(x, t, equations::AbstractShallowWaterEquations, mesh)\n\nSetup a truly discontinuous bottom topography function for this academic lake-at-rest test case of well-balancedness, i.e. eta is constant and v is zero everywhere. The error for this lake-at-rest test case ∫|η-η₀| should be around machine roundoff.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.is_hyperbolic_appproximation-Tuple{DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.is_hyperbolic_appproximation","text":"DispersiveShallowWater.is_hyperbolic_appproximation(equations)\n\nReturns Val{true}() if the equations are a hyperbolic approximation of another set of equations and Val{false}() otherwise (default). For example, the HyperbolicSerreGreenNaghdiEquations1D are a hyperbolic approximation of the SerreGreenNaghdiEquations1D.\n\nSee also hyperbolic_approximation_limit and prim2phys.\n\nnote: Implementation details\nThis function is mostly used for some internal dispatch. For example, it allows to return a reduced set of variables from initial conditions for hyperbolic approximations.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.lake_at_rest_error-Tuple{Any, DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.lake_at_rest_error","text":"lake_at_rest_error(q, equations)\n\nCalculate the error for the \"lake-at-rest\" test case where the waterheight_total eta = h + b should be a constant value over time (given by the value eta_0 passed to the equations when constructing them).\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.momentum-Tuple{Any, DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.momentum","text":"momentum(q, equations)\n\nReturn the momentum/discharge of the primitive variables q for a given set of equations, i.e., the waterheight times the velocity.\n\nq is a vector of the primitive variables at a single node, i.e., a vector of the correct length nvariables(equations).\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.prim2cons-Tuple{Any, AbstractShallowWaterEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.prim2cons","text":"prim2cons(q, equations)\n\nConvert the primitive variables q to the conserved variables for a given set of equations. q is a vector type of the correct length nvariables(equations). Notice the function doesn't include any error checks for the purpose of efficiency, so please make sure your input is correct. The inverse conversion is performed by cons2prim.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.prim2phys-Tuple{Any, DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.prim2phys","text":"prim2phys(q, equations)\n\nConvert the primitive variables q to the physically meaningful variables for a given set of equations. By default, this is the same as prim2prim for most equations. However, some equations like the HyperbolicSerreGreenNaghdiEquations1D return a reduced set of variables since they are a hyperbolic approximation of another set of equations (in this case the SerreGreenNaghdiEquations1D).\n\nSee also is_hyperbolic_appproximation and hyperbolic_approximation_limit.\n\nq is a vector type of the correct length nvariables(equations). Notice the function doesn't include any error checks for the purpose of efficiency, so please make sure your input is correct.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.prim2prim-Tuple{Any, DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.prim2prim","text":"prim2prim(q, equations)\n\nReturn the primitive variables q. While this function is as trivial as identity, it is also as useful.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.still_water_surface-Tuple{Any, DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.still_water_surface","text":"still_water_surface(q, equations)\n\nReturn the still water surface eta_0 (lake at rest) for a given set of equations.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.varnames","page":"DispersiveShallowWater","title":"DispersiveShallowWater.varnames","text":"varnames(conversion_function, equations)\n\nReturn the list of variable names when applying conversion_function to the primitive variables associated to equations. Common choices of the conversion_function are prim2prim, prim2cons, and prim2phys.\n\n\n\n\n\n","category":"function"},{"location":"ref/#DispersiveShallowWater.velocity-Tuple{Any, AbstractShallowWaterEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.velocity","text":"velocity(q, equations)\n\nReturn the velocity of the primitive variables q for a given set of equations.\n\nq is a vector of the primitive variables at a single node, i.e., a vector of the correct length nvariables(equations).\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.waterheight-Tuple{Any, DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.waterheight","text":"waterheight(q, equations)\n\nReturn the waterheight of the primitive variables q for a given set of equations, i.e., the waterheight h above the bathymetry b.\n\nq is a vector of the primitive variables at a single node, i.e., a vector of the correct length nvariables(equations).\n\nSee also waterheight_total, bathymetry.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.waterheight_total-Tuple{Any, DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.waterheight_total","text":"waterheight_total(q, equations)\n\nReturn the total waterheight of the primitive variables q for a given set of equations, i.e., the waterheight h plus the bathymetry b.\n\nq is a vector of the primitive variables at a single node, i.e., a vector of the correct length nvariables(equations).\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.HyperbolicSerreGreenNaghdiEquations1D","page":"DispersiveShallowWater","title":"DispersiveShallowWater.HyperbolicSerreGreenNaghdiEquations1D","text":"HyperbolicSerreGreenNaghdiEquations1D(; bathymetry_type = bathymetry_mild_slope,\n                                      gravity,\n                                      eta0 = 0.0,\n                                      lambda)\n\nHyperbolic approximation of the Serre-Green-Naghdi system in one spatial dimension. The equations for flat bathymetry are given by\n\nbeginaligned\n  h_t + (h v)_x = 0\n  h v_t + frac12 g (h^2)_x + frac12 h (v^2)_x\n    + biggl( fraclambda3 H (1 - H  h) biggr)_x = 0\n  h w_t + h v w_x = lambda (1 - H  h)\n  H_t + H_x u = w\nendaligned\n\nThe unknown quantities of the hyperbolized Serre-Green-Naghdi equations are the total water height eta = h + b and the velocity v. The gravitational acceleration gravity is denoted by g and the bottom topography (bathymetry) b = eta_0 - D. The water height above the bathymetry is therefore given by h = eta - eta_0 + D. The total water height is therefore given by eta = h + b.\n\nThere are two additional variables w approx -h v_x and H approx h compared to the SerreGreenNaghdiEquations1D. In the original papers of Gavrilyuk et al., the variable H is called eta. Here, we use eta for the total water height and H for auxiliary variable introduced in the hyperbolic approximation.\n\nnote: Initial conditions\nThe HyperbolicSerreGreenNaghdiEquations1D allow two options for specifying initial conditions:Returning the full set of variables q = (η, v, D, w, H)\nReturning a reduced set of variables q = (η, v, D) as required for the limit system SerreGreenNaghdiEquations1D of the hyperbolic approximation. The remaining variables w and H are initialized using the default initialization w approx -h v_x and H approx h using the derivative operator of the solver.\n\nThe relaxation parameter lambda (lambda) introduced to obtain this hyperbolic approximation of the SerreGreenNaghdiEquations1D influences the stiffness of the system. For lambda to infty, the hyperbolic Serre-Green-Naghdi equations converge (at least formally) to the original SerreGreenNaghdiEquations1D. However, the wave speeds of the hyperbolic system increase with increasing lambda, so that explicit time integration methods become more expensive.\n\nTwo types of bathymetry_type are supported:\n\nbathymetry_flat: flat bathymetry (typically b = 0 everywhere)\nbathymetry_mild_slope: variable bathymetry with mild-slope approximation\n\nFor the mild-slope approximation, the Serre-Green-Naghdi equations are\n\nbeginaligned\n  h_t + (h v)_x = 0\n  h v_t + frac12 g (h^2)_x + frac12 h (v^2)_x\n    + biggl( fraclambda3 H (1 - H  h) biggr)_x\n    + biggl( g h + fraclambda2 (1 - H  h) biggr) b_x = 0\n  h w_t + h v w_x = lambda (1 - H  h)\n  H_t + H_x u + frac32 b_x v = w\nendaligned\n\nReferences for the hyperbolized Serre-Green-Naghdi system can be found in\n\nFavrie and Gavrilyuk. A rapid numerical method for solving Serre-Green-Naghdi equations describing long free surface gravity waves DOI: 10.1088/1361-6544/aa712d\nBusto, Dumbser, Escalante, Favrie, and Gavrilyuk. On High Order ADER Discontinuous Galerkin Schemes for First Order Hyperbolic Reformulations of Nonlinear Dispersive Systems DOI: 10.1007/s10915-021-01429-8\n\nThe semidiscretization implemented here conserves\n\nthe total water mass (integral of h) as a linear invariant\nthe total modified energy\n\nfor periodic boundary conditions (see Ranocha and Ricchiuto (2024)). Additionally, it is well-balanced for the lake-at-rest stationary solution, see\n\nHendrik Ranocha and Mario Ricchiuto (2024) Structure-preserving approximations of the Serre-Green-Naghdi equations in standard and hyperbolic form arXiv: 2408.02665\n\n\n\n\n\n","category":"type"},{"location":"ref/#DispersiveShallowWater.energy_total_modified!-Tuple{Any, Any, HyperbolicSerreGreenNaghdiEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.energy_total_modified!","text":"DispersiveShallowWater.energy_total_modified!(e, q_global, equations::HyperbolicSerreGreenNaghdiEquations1D, cache)\n\nReturn the modified total energy e of the primitive variables q_global for the HyperbolicSerreGreenNaghdiEquations1D. It contains additional terms compared to the usual energy_total modeling non-hydrostatic contributions. The energy_total_modified is a conserved quantity (for periodic boundary conditions).\n\nFor a bathymetry_mild_slope (and a bathymetry_flat), the total modified energy is given by\n\nfrac12 g eta^2 + frac12 h v^2 +\nfrac16 h w^2 + fraclambda6 h (1 - eta  h)^2\n\nq_global is a vector of the primitive variables at ALL nodes.\n\nSee also energy_total_modified.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_manufactured-Tuple{Any, Any, HyperbolicSerreGreenNaghdiEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_manufactured","text":"initial_condition_manufactured(x, t, equations::HyperbolicSerreGreenNaghdiEquations1D, mesh)\n\nA smooth manufactured solution in combination with source_terms_manufactured, see\n\nHendrik Ranocha and Mario Ricchiuto (2024) Structure-preserving approximations of the Serre-Green-Naghdi equations in standard and hyperbolic form arXiv: 2408.02665\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_soliton-Tuple{Any, Any, HyperbolicSerreGreenNaghdiEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_soliton","text":"initial_condition_soliton(x, t, equations::HyperbolicSerreGreenNaghdiEquations1D, mesh)\n\nA soliton solution of the SerreGreenNaghdiEquations1D used for convergence tests in a periodic domain. This is physically the same as initial_condition_convergence_test for the SerreGreenNaghdiEquations1D. Please note that this is not an exact solution of the HyperbolicSerreGreenNaghdiEquations1D (only in the limit of the relaxation parameter lambda to infty).\n\nSee also initial_condition_convergence_test.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.prim2phys-Tuple{Any, HyperbolicSerreGreenNaghdiEquations1D}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.prim2phys","text":"prim2phys(q, equations::HyperbolicSerreGreenNaghdiEquations1D)\n\nReturn the physical variables eta v D used also by the SerreGreenNaghdiEquations1D from the main variables q for the HyperbolicSerreGreenNaghdiEquations1D.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.source_terms_manufactured-Tuple{Any, Any, Any, HyperbolicSerreGreenNaghdiEquations1D}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.source_terms_manufactured","text":"source_terms_manufactured(q, x, t, equations::HyperbolicSerreGreenNaghdiEquations1D, mesh)\n\nA smooth manufactured solution in combination with initial_condition_manufactured.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.SerreGreenNaghdiEquations1D","page":"DispersiveShallowWater","title":"DispersiveShallowWater.SerreGreenNaghdiEquations1D","text":"SerreGreenNaghdiEquations1D(; bathymetry_type = bathymetry_variable,\n                            gravity, eta0 = 0.0)\n\nSerre-Green-Naghdi system in one spatial dimension. The equations for flat bathymetry are given by\n\nbeginaligned\n  h_t + (h v)_x = 0\n  h v_t - frac13 (h^3 v_tx)_x + frac12 g (h^2)_x + frac12 h (v^2)_x + p_x = 0\n  p = frac13 h^3 v_x^2 - frac13 h^3 v v_xx\nendaligned\n\nThe unknown quantities of the Serre-Green-Naghdi equations are the total water height eta = h + b and the velocity v. The gravitational acceleration gravity is denoted by g and the bottom topography (bathymetry) b = eta_0 - D. The water height above the bathymetry is therefore given by h = eta - eta_0 + D. The total water height is therefore given by eta = h + b.\n\nThree types of bathymetry_type are supported:\n\nbathymetry_flat: flat bathymetry (typically b = 0 everywhere)\nbathymetry_mild_slope: variable bathymetry with mild-slope approximation\nbathymetry_variable: general variable bathymetry\n\nFor the mild-slope approximation, the Serre-Green-Naghdi equations are\n\nbeginaligned\n  h_t + (h v)_x = 0\n  h v_t - frac13 (h^3 v_tx)_x + frac12 (h^2 b_x v_t)_x - frac12 h^2 b_x v_tx + frac34 h b_x^2 v_t\n    + frac12 g (h^2)_x + g h b_x + frac12 h (v^2)_x\n    + p_x + frac32 fracph b_x = 0\n  p = frac13 h^3 v_x^2 - frac13 h^3 v v_xx\n    + frac12 h^2 v (b_x v)_x\nendaligned\n\nFor the general case of variable bathymetry without mild-slope approximation, the Serre-Green-Naghdi equations are\n\nbeginaligned\n  h_t + (h v)_x = 0\n  h v_t - frac13 (h^3 v_tx)_x + frac12 (h^2 b_x v_t)_x - frac12 h^2 b_x v_tx + h b_x^2 v_t\n    + frac12 g (h^2)_x + g h b_x + frac12 h (v^2)_x\n    + p_x + frac32 fracph b_x + psi b_x = 0\n  p = frac13 h^3 v_x^2 - frac13 h^3 v v_xx\n    + frac12 h^2 v (b_x v)_x\n  psi = frac14 h v (b_x v)_x\nendaligned\n\nReferences for the Serre-Green-Naghdi system can be found in\n\nSerre (1953) Contribution â l'étude des écoulements permanents et variables dans les canaux DOI: 10.1051/lhb/1953034\nGreen and Naghdi (1976) A derivation of equations for wave propagation in water of variable depth DOI: 10.1017/S0022112076002425\n\nThe semidiscretization implemented here conserves\n\nthe total water mass (integral of h) as a linear invariant\nthe total momentum (integral of h v) as a nonlinear invariant if the bathymetry is constant\nthe total modified energy\n\nfor periodic boundary conditions (see Ranocha and Ricchiuto (2024)). Additionally, it is well-balanced for the lake-at-rest stationary solution, see\n\nHendrik Ranocha and Mario Ricchiuto (2024) Structure-preserving approximations of the Serre-Green-Naghdi equations in standard and hyperbolic form arXiv: 2408.02665\n\n\n\n\n\n","category":"type"},{"location":"ref/#DispersiveShallowWater.energy_total_modified!-Tuple{Any, Any, SerreGreenNaghdiEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.energy_total_modified!","text":"DispersiveShallowWater.energy_total_modified!(e, q_global, equations::SerreGreenNaghdiEquations1D, cache)\n\nReturn the modified total energy e of the primitive variables q_global for the SerreGreenNaghdiEquations1D. It contains an additional term containing a derivative compared to the usual energy_total modeling non-hydrostatic contributions. The energy_total_modified is a conserved quantity (for periodic boundary conditions).\n\nFor a bathymetry_flat the total modified energy is given by\n\nfrac12 g eta^2 + frac12 h v^2 + frac16 h^3 v_x^2\n\nFor a bathymetry_mild_slope the total modified energy is given by\n\nfrac12 g eta^2 + frac12 h v^2 + frac16 h (-h v_x + 15 v b_x)^2\n\nFor a bathymetry_variable the total modified energy has the additional term\n\n+ frac18 h (v b_x)^2\n\nq_global is a vector of the primitive variables at ALL nodes. cache needs to hold the SBP operators used by the solver.\n\nSee also energy_total_modified.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_convergence_test-Tuple{Any, Any, SerreGreenNaghdiEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::SerreGreenNaghdiEquations1D, mesh)\n\nA soliton solution used for convergence tests in a periodic domain.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_manufactured-Tuple{Any, Any, SerreGreenNaghdiEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_manufactured","text":"initial_condition_manufactured(x, t, equations::SerreGreenNaghdiEquations1D, mesh)\n\nA smooth manufactured solution in combination with source_terms_manufactured.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.source_terms_manufactured-Tuple{Any, Any, Any, SerreGreenNaghdiEquations1D{DispersiveShallowWater.BathymetryFlat}}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.source_terms_manufactured","text":"source_terms_manufactured(q, x, t, equations::SerreGreenNaghdiEquations1D, mesh)\n\nA smooth manufactured solution in combination with initial_condition_manufactured.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.SvaerdKalischEquations1D","page":"DispersiveShallowWater","title":"DispersiveShallowWater.SvaerdKalischEquations1D","text":"SvaerdKalischEquations1D(; bathymetry_type = bathymetry_variable,\n                         gravity, eta0 = 0.0, alpha = 0.0,\n                         beta = 0.2308939393939394, gamma = 0.04034343434343434)\n\nDispersive system by Svärd and Kalisch (2023) in one spatial dimension. The equations for variable bathymetry are given in conservative variables by\n\nbeginaligned\n  h_t + (hv)_x = (hatalpha(hatalpha(h + b)_x)_x)_x\n  (hv)_t + (hv^2)_x + gh(h + b)_x = (hatalpha v(hatalpha(h + b)_x)_x)_x + (hatbeta v_x)_xt + frac12(hatgamma v_x)_xx + frac12(hatgamma v_xx)_x\nendaligned\n\nwhere hatalpha^2 = alphasqrtgDD^2, hatbeta = beta D^3, hatgamma = gammasqrtgDD^3. The coefficients alpha, beta and gamma are provided in dimensionless form and D = eta_0 - b is the still-water depth and eta0 is the still-water surface (lake-at-rest). The equations can be rewritten in primitive variables as\n\nbeginaligned\n  eta_t + ((eta + D)v)_x = (hatalpha(hatalphaeta_x)_x)_x\n  v_t(eta + D) - v((eta + D)v)_x + ((eta + D)v^2)_x + g(eta + D)eta_x = (hatalpha v(hatalphaeta_x)_x)_x - v(hatalpha(hatalphaeta_x)_x)_x + (hatbeta v_x)_xt + frac12(hatgamma v_x)_xx + frac12(hatgamma v_xx)_x\nendaligned\n\nThe unknown quantities of the Svärd-Kalisch equations are the total water height eta and the velocity v. The gravitational acceleration gravity is denoted by g and the bottom topography (bathymetry) b = eta_0 - D. The water height above the bathymetry is therefore given by h = eta - eta_0 + D.\n\nCurrently, the equations only support a general variable bathymetry, see bathymetry_variable.\n\nSvärdKalischEquations1D is an alias for SvaerdKalischEquations1D.\n\nThe equations by Svärd and Kalisch are presented and analyzed in Svärd and Kalisch (2023). The semidiscretization implemented here conserves\n\nthe total water mass (integral of h) as a linear invariant\nthe total momentum (integral of h v) as a nonlinear invariant for flat bathymetry\nthe total modified energy\n\nfor periodic boundary conditions (see Lampert, Ranocha). Additionally, it is well-balanced for the lake-at-rest stationary solution, see Lampert and Ranocha (2024).\n\nMagnus Svärd, Henrik Kalisch (2023) A novel energy-bounded Boussinesq model and a well-balanced and stable numerical discretization arXiv: 2302.09924\nJoshua Lampert, Hendrik Ranocha (2024) Structure-Preserving Numerical Methods for Two Nonlinear Systems of Dispersive Wave Equations DOI: 10.48550/arXiv.2402.16669\n\n\n\n\n\n","category":"type"},{"location":"ref/#DispersiveShallowWater.energy_total_modified!-Tuple{Any, Any, SvaerdKalischEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.energy_total_modified!","text":"DispersiveShallowWater.energy_total_modified!(e, q_global, equations::SvaerdKalischEquations1D, cache)\n\nReturn the modified total energy e of the primitive variables q_global for the SvaerdKalischEquations1D. It contains an additional term containing a derivative compared to the usual energy_total modeling non-hydrostatic contributions. The energy_total_modified is a conserved quantity (for periodic boundary conditions).\n\nIt is given by\n\nfrac12 g eta^2 + frac12 h v^2 + frac12 hatbeta v_x^2\n\nq_global is a vector of the primitive variables at ALL nodes. cache needs to hold the SBP operators used by the solver.\n\nSee also energy_total_modified.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_manufactured-Tuple{Any, Any, SvaerdKalischEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_manufactured","text":"initial_condition_manufactured(x, t, equations::SvaerdKalischEquations1D, mesh)\n\nA smooth manufactured solution in combination with source_terms_manufactured.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_manufactured_reflecting-Tuple{Any, Any, SvaerdKalischEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_manufactured_reflecting","text":"initial_condition_manufactured_reflecting(x, t, equations::SvaerdKalischEquations1D, mesh)\n\nA smooth manufactured solution for reflecting boundary conditions in combination with source_terms_manufactured_reflecting.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.source_terms_manufactured-Tuple{Any, Any, Any, SvaerdKalischEquations1D}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.source_terms_manufactured","text":"source_terms_manufactured(q, x, t, equations::SvaerdKalischEquations1D, mesh)\n\nA smooth manufactured solution in combination with initial_condition_manufactured.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.source_terms_manufactured_reflecting-Tuple{Any, Any, Any, SvaerdKalischEquations1D}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.source_terms_manufactured_reflecting","text":"source_terms_manufactured_reflecting(q, x, t, equations::SvaerdKalischEquations1D, mesh)\n\nA smooth manufactured solution for reflecting boundary conditions in combination with initial_condition_manufactured_reflecting.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Linear-dispersion-relations","page":"DispersiveShallowWater","title":"Linear dispersion relations","text":"","category":"section"},{"location":"ref/#DispersiveShallowWater.EulerEquations1D","page":"DispersiveShallowWater","title":"DispersiveShallowWater.EulerEquations1D","text":"EulerEquations1D(; gravity, eta0 = 0.0)\n\nA struct representing the 1D Euler equations with a given gravitational acceleration gravity and a still-water surface eta0.\n\nnote: Note\nIn DispersiveShallowWater.jl, the Euler equations are only used for computing the full linear dispersion relationomega(k) = sqrtg k tanh(h_0 k)see LinearDispersionRelation and wave_speed. The EulerEquations1D cannot be solved as a system of equations.\n\n\n\n\n\n","category":"type"},{"location":"ref/#DispersiveShallowWater.LinearDispersionRelation","page":"DispersiveShallowWater","title":"DispersiveShallowWater.LinearDispersionRelation","text":"LinearDispersionRelation(ref_height)\n\nA struct representing a linear dispersion relation omega(k) of an equation. The reference water height h_0 is given by ref_height. A dispersion relation can be called as disp_rel(equations, k) to compute the wave frequency omega(k) for a given wavenumber k and a set of equations.\n\nSee also wave_speed for computing the wave speed c = omega(k)  k given a linear dispersion relation.\n\n\n\n\n\n","category":"type"},{"location":"ref/#DispersiveShallowWater.wave_speed-Tuple{LinearDispersionRelation, Any, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.wave_speed","text":"wave_speed(disp_rel, equations, k; normalize = false)\n\nCompute the wave speed c for a given wavenumber k using the LinearDispersionRelation disp_rel of the equations. The wave speed is given by c = omega(k)  k. If normalize is true, the wave speed is normalized by the shallow water wave speed sqrtg h_0, where g is the gravitational acceleration of the equations and h_0 is the ref_height of the dispersion relation disp_rel.\n\nSee also LinearDispersionRelation.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Mesh","page":"DispersiveShallowWater","title":"Mesh","text":"","category":"section"},{"location":"ref/#DispersiveShallowWater.Mesh1D","page":"DispersiveShallowWater","title":"DispersiveShallowWater.Mesh1D","text":"Mesh1D\n\nStruct that holds the information for a simple homogeneous one-dimensional mesh.\n\n\n\n\n\n","category":"type"},{"location":"ref/#DispersiveShallowWater.Mesh1D-Tuple{Any, Any, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.Mesh1D","text":"Mesh1D(xmin, xmax, N)\n\nCreate a simple homogeneous one-dimensional mesh from xmin to xmax with N nodes.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Boundary-conditions","page":"DispersiveShallowWater","title":"Boundary conditions","text":"","category":"section"},{"location":"ref/#DispersiveShallowWater.boundary_condition_periodic","page":"DispersiveShallowWater","title":"DispersiveShallowWater.boundary_condition_periodic","text":"boundary_condition_periodic = DispersiveShallowWater.BoundaryConditionPeriodic()\n\nA singleton struct indicating periodic boundary conditions.\n\n\n\n\n\n","category":"constant"},{"location":"ref/#DispersiveShallowWater.boundary_condition_reflecting","page":"DispersiveShallowWater","title":"DispersiveShallowWater.boundary_condition_reflecting","text":"boundary_condition_reflecting = DispersiveShallowWater.BoundaryConditionReflecting()\n\nA singleton struct indicating reflecting boundary conditions.\n\n\n\n\n\n","category":"constant"},{"location":"ref/#Solver","page":"DispersiveShallowWater","title":"Solver","text":"","category":"section"},{"location":"ref/#DispersiveShallowWater.AbstractSolver","page":"DispersiveShallowWater","title":"DispersiveShallowWater.AbstractSolver","text":"AbstractSolver\n\nAn abstract supertype of specific solvers.\n\n\n\n\n\n","category":"type"},{"location":"ref/#DispersiveShallowWater.Solver","page":"DispersiveShallowWater","title":"DispersiveShallowWater.Solver","text":"Solver\n\nA struct that holds the summation-by-parts (SBP) operators that are used for the spatial discretization.\n\n\n\n\n\n","category":"type"},{"location":"ref/#DispersiveShallowWater.Solver-Tuple{Any, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.Solver","text":"Solver(mesh, accuracy_order)\n\nCreate a solver, where the summation-by-parts (SBP) operators are of order accuracy_order and associated to the mesh.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.Solver-Union{Tuple{RealT}, Tuple{SummationByPartsOperators.AbstractDerivativeOperator{RealT}, Union{Nothing, AbstractMatrix{RealT}, SummationByPartsOperators.AbstractDerivativeOperator{RealT}}}} where RealT","page":"DispersiveShallowWater","title":"DispersiveShallowWater.Solver","text":"Solver(D1, D2)\n\nCreate a solver, where D1 is an AbstractDerivativeOperator from SummationByPartsOperators.jl of first derivative_order and D2 is an AbstractDerivativeOperator of second derivative_order or an AbstractMatrix. It can also be nothing if no second derivative is used by the discretization. Both summation-by-parts operators should be associated with the same grid.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Semidiscretization","page":"DispersiveShallowWater","title":"Semidiscretization","text":"","category":"section"},{"location":"ref/#DispersiveShallowWater.Semidiscretization","page":"DispersiveShallowWater","title":"DispersiveShallowWater.Semidiscretization","text":"Semidiscretization\n\nA struct containing everything needed to describe a spatial semidiscretization of an equation.\n\n\n\n\n\n","category":"type"},{"location":"ref/#DispersiveShallowWater.Semidiscretization-NTuple{4, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.Semidiscretization","text":"Semidiscretization(mesh, equations, initial_condition, solver;\n                   source_terms=nothing,\n                   boundary_conditions=boundary_condition_periodic,\n                   RealT=real(solver),\n                   uEltype=RealT,\n                   initial_cache=(tmp1 = Array{RealT}(undef, nnodes(mesh)),))\n\nConstruct a semidiscretization of a PDE.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.jacobian-Tuple{Semidiscretization}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.jacobian","text":"DispersiveShallowWater.jacobian(semi::Semidiscretization;\n                                t = 0.0,\n                                q0 = compute_coefficients(semi.initial_condition, t, semi))\n\nUse the right-hand side operator of the semidiscretization semi and forward mode automatic differentiation to compute the Jacobian J of the semidiscretization semi at the state q0.\n\nwarning: Warning\nThis functionality may not be implemented for all equations.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SummationByPartsOperators.grid-Tuple{Semidiscretization}","page":"DispersiveShallowWater","title":"SummationByPartsOperators.grid","text":"grid(semi)\n\nGet the grid of a semidiscretization.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SummationByPartsOperators.semidiscretize-Tuple{Semidiscretization, Any}","page":"DispersiveShallowWater","title":"SummationByPartsOperators.semidiscretize","text":"semidiscretize(semi::Semidiscretization, tspan)\n\nWrap the semidiscretization semi as an ODE problem in the time interval tspan that can be passed to solve from the SciML ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Callbacks","page":"DispersiveShallowWater","title":"Callbacks","text":"","category":"section"},{"location":"ref/#DispersiveShallowWater.AnalysisCallback","page":"DispersiveShallowWater","title":"DispersiveShallowWater.AnalysisCallback","text":"AnalysisCallback(semi; interval=0,\n                       extra_analysis_errors=Symbol[],\n                       extra_analysis_integrals=(),\n                       io=stdout)\n\nAnalyze a numerical solution every interval time steps. The L2- and the L∞-norm for each component are computed by default. Additional errors can be computed, e.g. by passing extra_analysis_errors = (:conservation_error,).\n\nFurther scalar functions func in extra_analysis_integrals are applied to the numerical solution and integrated over the computational domain. Some examples for this are entropy, and energy_total. You can also write your own function with the same signature as the examples listed above and pass it via extra_analysis_integrals. The computed errors and intergrals are saved for each timestep and can be obtained by calling errors and integrals.\n\nDuring the Simulation, the AnalysisCallback will print information to io.\n\n\n\n\n\n","category":"type"},{"location":"ref/#DispersiveShallowWater.errors-Union{Tuple{SciMLBase.DiscreteCallback{Condition, Affect!}}, Tuple{Affect!}, Tuple{Condition}} where {Condition, Affect!<:AnalysisCallback}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.errors","text":"errors(analysis_callback)\n\nReturn the computed errors for each timestep as a named tuple. The shape of each entry is (nvariables, ntimesteps).\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.integrals-Union{Tuple{SciMLBase.DiscreteCallback{Condition, Affect!}}, Tuple{Affect!}, Tuple{Condition}} where {Condition, Affect!<:AnalysisCallback}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.integrals","text":"integrals(analysis_callback)\n\nReturn the computed integrals for each timestep as a named tuple.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.tstops-Union{Tuple{SciMLBase.DiscreteCallback{Condition, Affect!}}, Tuple{Affect!}, Tuple{Condition}} where {Condition, Affect!<:AnalysisCallback}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.tstops","text":"tstops(analysis_callback)\n\nReturn the time values that correspond to the saved values of the errors and integrals.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.RelaxationCallback","page":"DispersiveShallowWater","title":"DispersiveShallowWater.RelaxationCallback","text":"RelaxationCallback(invariant)\n\nUse a relaxation method in time in order to exactly preserve the (nonlinear) invariant for a conservative semidiscretization. A possible choice for invariant is invariant = entropy.\n\nReference\n\nHendrik Ranocha, Mohammed Sayyari, Lisandro Dalcin, Matteo Parsani, David I. Ketcheson (2020) Relaxation Runge–Kutta Methods: Fully-Discrete Explicit Entropy-Stable Schemes for the Compressible Euler and Navier–Stokes Equations DOI: 10.1137/19M1263480\n\n\n\n\n\n","category":"type"},{"location":"ref/#DispersiveShallowWater.SummaryCallback","page":"DispersiveShallowWater","title":"DispersiveShallowWater.SummaryCallback","text":"SummaryCallback(io::IO = stdout)\n\nCreate and return a callback that resets the timer at the beginning of a simulation and prints the timer values at the end of the simulation.\n\n\n\n\n\n","category":"type"},{"location":"ref/#Utilities","page":"DispersiveShallowWater","title":"Utilities","text":"","category":"section"},{"location":"ref/#DispersiveShallowWater.convergence_test-Tuple{Module, AbstractString, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.convergence_test","text":"convergence_test([mod::Module=Main,] example::AbstractString, iterations; io::IO = stdout, kwargs...)\nconvergence_test([mod::Module=Main,] example::AbstractString, Ns::AbstractVector; io::IO = stdout, kwargs...)\n\nRun multiple simulations using the setup given in example and compute the experimental order of convergence (EOC) in the L^2 and L^infty norm. If iterations is passed as integer, in each iteration, the resolution of the respective mesh will be doubled. If Ns is passed as vector, the simulations will be run for each value of Ns. Additional keyword arguments kwargs... and the optional module mod are passed directly to trixi_include.\n\nAdjusted from Trixi.jl.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.default_example-Tuple{}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.default_example","text":"default_example()\n\nReturn the path to an example that can be used to quickly see DispersiveShallowWater.jl in action. See also examples_dir and get_examples.\n\nCopied from Trixi.jl.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.examples_dir-Tuple{}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.examples_dir","text":"examples_dir()\n\nReturn the directory where the example files provided with DispersiveShallowWater.jl are located. If DispersiveShallowWater is installed as a regular package (with ]add DispersiveShallowWater), these files are read-only and should not be modified. To find out which files are available, use, e.g., readdir.\n\nCopied from Trixi.jl.\n\nExamples\n\nreaddir(examples_dir())\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.get_examples-Tuple{}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.get_examples","text":"get_examples()\n\nReturn a list of all examples that are provided by DispersiveShallowWater.jl. See also examples_dir and default_example.\n\nCopied from Trixi.jl.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.@autoinfiltrate","page":"DispersiveShallowWater","title":"DispersiveShallowWater.@autoinfiltrate","text":"@autoinfiltrate\n@autoinfiltrate condition::Bool\n\nInvoke the @infiltrate macro of the package Infiltrator.jl to create a breakpoint for ad-hoc interactive debugging in the REPL. If the optional argument condition is given, the breakpoint is only enabled if condition evaluates to true.\n\nAs opposed to using Infiltrator.@infiltrate directly, this macro does not require Infiltrator.jl to be added as a dependency to DispersiveShallowWater.jl. As a bonus, the macro will also attempt to load the Infiltrator module if it has not yet been loaded manually.\n\nNote: For this macro to work, the Infiltrator.jl package needs to be installed in your current Julia environment stack.\n\nSee also: Infiltrator.jl\n\nwarning: Internal use only\nPlease note that this macro is intended for internal use only. It is not part of the public API of DispersiveShallowWater.jl, and it thus can altered (or be removed) at any time without it being considered a breaking change.\n\n\n\n\n\n","category":"macro"},{"location":"#DispersiveShallowWater.jl","page":"Home","title":"DispersiveShallowWater.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Docs-stable) (Image: Docs-dev) (Image: Build Status) (Image: codecov) (Image: Coveralls) (Image: Aqua QA) (Image: License: MIT) (Image: DOI)","category":"page"},{"location":"","page":"Home","title":"Home","text":"DispersiveShallowWater.jl is a Julia package that implements structure-preserving numerical methods for dispersive shallow water models. To date, it provides provably conservative, entropy-conserving and well-balanced numerical schemes for some dispersive shallow water models:","category":"page"},{"location":"","page":"Home","title":"Home","text":"the Benjamin-Bona-Mahony (BBM) equation, also known as regularized long-wave equation,\nthe BBM-BBM equations with varying bottom topography,\nthe dispersive shallow water model proposed by Magnus Svärd and Henrik Kalisch,\nthe Serre-Green-Naghdi equations in standard and hyperbolic form.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The semidiscretizations are based on summation-by-parts (SBP) operators, which are implemented in SummationByPartsOperators.jl. To obtain fully discrete schemes, the time integration methods from OrdinaryDiffEq.jl are used to solve the resulting ordinary differential equations. Fully discrete entropy-conservative methods can be obtained by using the relaxation method provided by DispersiveShallowWater.jl.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have not yet installed Julia, then you first need to download Julia. Please follow the instructions for your operating system. DispersiveShallowWater.jl works with Julia v1.10 and newer. DispersiveShallowWater.jl is a registered Julia package. Therefore, you can install it by executing the following commands from the Julia REPL","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\n\njulia> Pkg.add([\"DispersiveShallowWater\", \"OrdinaryDiffEqTsit5\", \"Plots\"])","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition, this installs the packages OrdinaryDiffEqTsit5.jl from OrdinaryDiffEq.jl used for time-integration and Plots.jl to visualize the results. If you want to use other time integration methods than Tsit5, you can install the respective subpackage or OrdinaryDiffEq.jl, which will install every available solver. If you want to use other SBP operators than the default operators that DispersiveShallowWater.jl uses, then you also need SummationByPartsOperators.jl, which can be installed running","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Pkg.add(\"SummationByPartsOperators\")","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the Julia REPL, first load the package DispersiveShallowWater.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using DispersiveShallowWater","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can run a basic simulation that solves the BBM-BBM equations by executing","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> include(default_example());","category":"page"},{"location":"","page":"Home","title":"Home","text":"The result can be visualized by using the package Plots.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Plots\njulia> plot(semi => sol)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The command plot expects a Pair consisting of a Semidiscretization and an ODESolution. The visualization can also be customized, see the documentation for more details. Other examples can be found in the subdirectory examples/. A list of all examples is returned by running get_examples(). You can pass the filename of one of the examples or your own simulation file to include in order to run it, e.g., include(joinpath(examples_dir(), \"svaerd_kalisch_1d\", \"svaerd_kalisch_1d_dingemans_relaxation.jl\")).","category":"page"},{"location":"#Referencing","page":"Home","title":"Referencing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can directly refer to DispersiveShallowWater.jl as","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{lampert2023dispersive,\n  title={{D}ispersive{S}hallow{W}ater.jl: {S}tructure-preserving numerical\n         methods for dispersive shallow water models},\n  author={Lampert, Joshua and Ranocha, Hendrik},\n  year={2023},\n  month={10},\n  howpublished={\\url{https://github.com/NumericalMathematics/DispersiveShallowWater.jl}},\n  doi={10.5281/zenodo.10034636}\n}","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is developed and maintained by Joshua Lampert (University of Hamburg) with contributions from Hendrik Ranocha (Johannes Gutenberg University Mainz). Some parts of this repository are based on parts of Dispersive-wave-schemes-notebooks. A Broad Class of Conservative Numerical Methods for Dispersive Wave Equations by Hendrik Ranocha, Dimitrios Mitsotakis and David Ketcheson. The code structure is inspired by Trixi.jl.","category":"page"},{"location":"#License-and-contributing","page":"Home","title":"License and contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DispersiveShallowWater.jl is published under the MIT license (see License). We are pleased to accept contributions from everyone, preferably in the form of a PR.","category":"page"}]
}
